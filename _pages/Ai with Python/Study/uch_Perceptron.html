<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대화형 퍼셉트론 학습: 선형에서 비선형으로</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: "Warm Neutrals with Blue Accent" -->
    <!-- Application Structure Plan: 이 SPA는 '이론 -> 성공 -> 한계 -> 해결'의 서사적 구조를 따릅니다. 1) '퍼셉트론이란?' 섹션에서 기본 이론을 통합 설명합니다. 2) '퍼셉트론의 성공과 한계' 섹션에서 탭 인터페이스를 통해 AND, OR, NAND의 성공 사례와 XOR의 실패 사례를 명확히 비교하며 보여줍니다. 3) '해결책: 다층 퍼셉트론' 섹션에서 MLP가 어떻게 XOR 문제를 극복하는지 시각적으로 증명합니다. 이 구조는 사용자가 점진적으로 개념을 쌓아 올리고, 문제와 해결책을 극적으로 대비하여 보도록 설계되었습니다. -->
    <!-- Visualization & Content Choices: 1. (이론) 구조도: HTML/CSS로 퍼셉트론의 흐름(입력->가중합->활성화->출력)을 시각화. 가중합 수식은 제공된 이미지 사용. 2. (비교/한계) 논리 게이트: Chart.js 산점도(결정 경계)와 선 그래프(오류)를 사용하여 AND/OR/NAND의 선형 분리 성공과 XOR의 실패를 시각적으로 대비시킴. 3. (해결책) MLP: 제공된 이미지(model1.png)로 비선형 결정 경계를 보여주고, Chart.js로 손실 곡선의 수렴을 보여주어 MLP의 우수성을 증명. 모든 시각화는 Canvas 기반의 Chart.js 또는 HTML/CSS/IMG를 사용하며, SVG/Mermaid는 사용하지 않음. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f8f7f4; color: #4a4a4a; }
        .chart-container { position: relative; width: 100%; max-width: 450px; margin-left: auto; margin-right: auto; height: 320px; max-height: 45vh; }
        .chart-container img { width: 100%; height: 100%; object-fit: contain; }
        .code-block { display: none; background-color: #2d3748; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; font-size: 0.875rem; line-height: 1.6; }
        .code-block-visible { display: block; }
        .tab-btn { transition: all 0.3s ease-in-out; border-bottom: 3px solid transparent; }
        .tab-btn.active { color: #3b82f6; border-color: #3b82f6; }
        .content-section { display: none; }
        .content-section.active { display: block; }
        .flow-diagram-arrow { position: relative; top: 50%; transform: translateY(-50%); }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto px-4 py-8 md:py-12">
        <header class="text-center mb-16">
            <h1 class="text-4xl md:text-5xl font-bold text-[#34568B] mb-3">퍼셉트론: 선형에서 비선형으로의 여정</h1>
            <p class="text-lg text-slate-600 max-w-3xl mx-auto">단일 퍼셉트론의 기본 원리부터 선형 분리의 한계, 그리고 다층 퍼셉트론(MLP)을 통한 문제 해결까지 대화형으로 탐험합니다.</p>
        </header>

        <main>
            <!-- Section 1: 퍼셉트론이란? -->
            <section class="mb-20">
                <h2 class="text-3xl font-bold mb-8 text-center text-[#34568B]">1. 퍼셉트론: 인공 뉴런의 시작</h2>
                <div class="bg-white p-8 rounded-xl shadow-lg max-w-5xl mx-auto">
                    <h3 class="text-2xl font-semibold mb-4 text-[#34568B]">1.1 퍼셉트론이란?</h3>
                    <p class="mb-6 text-slate-700 leading-relaxed">
                        퍼셉트론은 1957년 제안된 인공 신경망의 가장 기본적인 단위로, 생물학적 뉴런의 동작을 수학적으로 모델링합니다. 여러 개의 입력 신호를 받아 각각의 **가중치(Weight)**를 곱하고, 그 합(가중합)에 **편향(Bias)**을 더한 뒤, **활성화 함수(Activation Function)**를 통해 최종 출력 신호(0 또는 1)를 결정합니다. 이 간단한 구조를 통해 퍼셉트론은 두 그룹으로 나뉘는 데이터(이진 분류)를 구분하는 방법을 학습할 수 있습니다.
                    </p>
                    <div class="bg-[#f8f7f4] p-6 rounded-lg my-8">
                        <h3 class="text-xl font-semibold text-center mb-6 text-slate-800">퍼셉트론의 동작 흐름</h3>
                        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                            <div class="text-center p-4 bg-white rounded-lg shadow w-32"><strong>입력 (Inputs)</strong><p class="text-sm text-slate-500">x₁, x₂</p></div>
                            <div class="flow-diagram-arrow text-2xl text-slate-400">→</div>
                            <div class="text-center p-4 bg-white rounded-lg shadow w-32"><strong>가중치/편향</strong><p class="text-sm text-slate-500">w₁, w₂, b</p></div>
                            <div class="flow-diagram-arrow text-2xl text-slate-400">→</div>
                            <div class="text-center p-4 bg-white rounded-lg shadow w-32"><strong>가중합 (Σ)</strong><p class="text-sm text-slate-500">z = Σ(wᵢxᵢ) + b</p></div>
                            <div class="flow-diagram-arrow text-2xl text-slate-400">→</div>
                            <div class="text-center p-4 bg-white rounded-lg shadow w-32"><strong>활성화 함수</strong><p class="text-sm text-slate-500">Step Function</p></div>
                            <div class="flow-diagram-arrow text-2xl text-slate-400">→</div>
                            <div class="text-center p-4 bg-white rounded-lg shadow w-32"><strong>출력 (Output)</strong><p class="text-sm text-slate-500">0 or 1</p></div>
                        </div>
                    </div>
                    <h3 class="text-2xl font-semibold mb-4 text-[#34568B] mt-8">1.2 퍼셉트론의 동작 방식 세부 정보</h3>
                    <p class="mb-4 text-slate-700 leading-relaxed">
                        퍼셉트론은 **지도 학습(supervised learning)** 방식으로 학습합니다. 즉, 입력 데이터와 그에 해당하는 정답(레이블)을 함께 사용하여 모델을 훈련시키며, 학습 과정은 다음과 같은 반복적인 단계로 진행됩니다.
                    </p>
                    <ol class="list-decimal list-inside text-slate-700 space-y-2">
                        <li>
                            <strong>초기화:</strong> 퍼셉트론 학습의 시작 단계입니다.
                            <ul class="list-disc list-inside ml-5 text-slate-600 space-y-1 mt-1">
                                <li>퍼셉트론의 가중치($w_i$)와 편향($b$)을 작은 임의의 값(종종 0)으로 초기화합니다. 이 값들은 학습을 통해 점차 최적의 값으로 수렴합니다.</li>
                                <li>**학습률($\eta$)**도 이 단계에서 설정됩니다. 학습률은 가중치와 편향을 얼마나 크게 업데이트할지를 결정하는 중요한 값입니다.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>예측:</strong> 현재 가중치와 편향을 사용하여 출력 값을 계산합니다.
                            <ul class="list-disc list-inside ml-5 text-slate-600 space-y-1 mt-1">
                                <li>훈련 데이터의 한 샘플을 입력으로 받아 가중합($z = \sum_{i} (w_i x_i) + b$)을 계산합니다.</li>
                                <li>계산된 가중합($z$)을 **활성화 함수**에 적용하여 퍼셉트론의 최종 출력 값($\hat{y}$, 예측 값)을 얻습니다. 퍼셉트론은 가중합이 0보다 크거나 같으면 1을, 그렇지 않으면 0을 출력하는 계단 함수를 사용합니다.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>오류 계산:</strong> 예측 값과 실제 정답 사이의 차이를 분석합니다.
                            <ul class="list-disc list-inside ml-5 text-slate-600 space-y-1 mt-1">
                                <li>예측된 출력 값($\hat{y}$)과 실제 정답($y$)을 비교하여 오류($\text{error} = y - \hat{y}$)를 계산합니다.</li>
                                <li>이 오류는 퍼셉트론이 얼마나 정확하게 예측했는지 나타내는 지표가 됩니다. 예를 들어, 예측이 0인데 정답이 1이면 오류는 $+1$이 되고, 예측이 1인데 정답이 0이면 오류는 $-1$이 됩니다.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>가중치 및 편향 업데이트:</strong> 오류를 줄이는 방향으로 모델의 매개변수를 조정합니다.
                            <ul class="list-disc list-inside ml-5 text-slate-600 space-y-1 mt-1">
                                <li>오류가 발생하면, 오류의 방향과 크기에 따라 가중치와 편향을 업데이트하여 다음번 예측이 더 정확해지도록 합니다. 이 업데이트는 퍼셉트론 학습 규칙을 따릅니다:
                                    <div class="bg-gray-100 p-4 rounded-lg mt-2 mb-2">
                                        <p class="font-mono text-sm text-slate-800">
                                            <!-- $w_n = w_n-1 + lr (y - \hat{y}) \times x$ <br>
                                            $b_{new} = b_{old} + \eta \times (y - \hat{y})$ -->
                                            <p>w<sub>new</sub> = w<sub>old</sub> + η × (y - ŷ) × x</p>
                                            <p>b<sub>new</sub> = b<sub>old</sub> + η × (y - ŷ)</p>
                                        </p>
                                    </div>
                                    <p class="text-sm text-slate-600 mt-2">
                                        여기서 η(eta)는 <strong>학습률(learning rate)</strong>으로, 가중치를 얼마나 크게 업데이트할지를 결정하는 값입니다. y는 실제 정답, ŷ는 예측 값을 의미하며, x는 해당 입력 신호입니다.
                                        <ul>
                                            <li><strong>오차에 비례한 가중치 조정:</strong> 오류(y - ŷ)가 크면 가중치 조정 폭도 커집니다.</li>
                                            <li><strong>반복적 학습으로 오차 최소화:</strong> 이 과정을 반복하며 오차가 점진적으로 줄어들도록 합니다.</li>
                                        </ul>
                                    </p>
                                    <p class="text-sm text-slate-600 mt-4">
                                        <strong>학습의 방향과 크기 결정 요인:</strong>
                                        <ul>
                                            <li><strong>오류의 크기:</strong> 오류(y - ŷ)가 클수록 가중치와 편향의 조정 폭이 커져 모델이 더 빨리 학습할 수 있습니다.</li>
                                            <li><strong>학습률(η):</strong> 학습률이 높으면 가중치 업데이트가 크고 학습 속도가 빠르지만, 불안정하거나 최적점을 놓칠 위험이 있습니다(과대 학습 가능성). 학습률이 낮으면 안정적이고 느리게 수렴하지만, 지역 최솟값에 갇힐 수 있습니다. 적절한 η 값 선택은 학습의 적절화를 위해 중요합니다.</li>
                                            <li><strong>현재 입력(x):</strong> 입력(x) 값이 가중치 업데이트 방향을 결정하는 데 기여합니다.</li>
                                            <li><strong>목표값과 예측값의 차이:</strong> 오류(y - ŷ)는 모델이 목표값에서 얼마나 벗어났는지 정확히 알려주며, 이 정보를 사용하여 매개변수를 조정합니다.</li>
                                            <li><strong>손실 함수 최소화의 핵심 요소:</strong> 이 업데이트 규칙은 궁극적으로 손실 함수를 최소화하여 모델이 더 정확한 예측을 하도록 돕습니다.</li>
                                            <li><strong>과적합 방지에 활용:</strong> 적절한 학습률과 반복 횟수(에포크)는 모델이 훈련 데이터에 너무 과적합되지 않도록 도와주며, 이는 검증 세트(validation set)를 통해 확인할 수 있습니다.</li>
                                        </ul>
                                    </p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <strong>반복:</strong> 전체 훈련 데이터셋을 여러 번 반복 학습합니다.
                            <ul class="list-disc list-inside ml-5 text-slate-600 space-y-1 mt-1">
                                <li>모든 훈련 데이터 샘플에 대해 2~4단계를 반복합니다. 이 과정을 한 번 반복하는 것을 **에포크(epoch)**라고 합니다.</li>
                                <li>여러 에포크에 걸쳐 학습을 진행함으로써 가중치와 편향이 최적의 값에 수렴하도록 하여 모델의 성능을 향상시킵니다.</li>
                            </ul>
                        </li>
                    </ol>
                </div>
            </section>

            <!-- Section 2: 퍼셉트론의 성공과 한계 -->
            <section class="mb-20">
                <h2 class="text-3xl font-bold mb-8 text-center text-[#34568B]">2. 퍼셉트론의 성공과 한계: 대화형 실습</h2>
                <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg max-w-6xl mx-auto">
                    <p class="text-center text-slate-600 max-w-3xl mx-auto mb-8">
                        퍼셉트론은 데이터 공간을 하나의 직선으로 나누어 문제를 해결합니다. 이렇게 직선으로 완벽하게 분류 가능한 문제를 '선형 분리 가능'하다고 합니다. 아래 탭을 눌러 다양한 논리 게이트에서 퍼셉트론이 어떻게 작동하는지, 그리고 어떤 한계에 부딪히는지 직접 확인해보세요.
                    </p>
                    <div class="flex justify-center border-b border-slate-200 mb-6 flex-wrap">
                        <button id="btn-and" class="tab-btn active py-3 px-5 font-semibold text-slate-600">AND Gate (성공)</button>
                        <button id="btn-or" class="tab-btn py-3 px-5 font-semibold text-slate-600">OR Gate (성공)</button>
                        <button id="btn-nand" class="tab-btn py-3 px-5 font-semibold text-slate-600">NAND Gate (성공)</button>
                        <button id="btn-xor" class="tab-btn py-3 px-5 font-semibold text-red-600">XOR Gate (실패)</button>
                    </div>
                    
                    <div id="content-container">
                        <!-- Content for each gate will be injected here by JS -->
                    </div>
                </div>
            </section>

            <!-- Section 3: MLP 해결책 -->
            <section>
                <h2 class="text-3xl font-bold mb-8 text-center text-[#34568B]">3. 해결책: 다층 퍼셉트론 (MLP)</h2>
                 <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg max-w-6xl mx-auto">
                    <p class="text-center text-slate-600 max-w-3xl mx-auto mb-6">
                        단일 퍼셉트론의 한계는 **다층 퍼셉트론(MLP)**으로 극복할 수 있습니다. MLP는 입력층과 출력층 사이에 하나 이상의 '은닉층(Hidden Layer)'을 추가하여, 단일 직선이 아닌 복잡한 곡선 형태의 결정 경계를 만들어냅니다.
                    </p>
                    <p class="text-center text-slate-600 max-w-3xl mx-auto mb-8 font-semibold text-green-700">
                        이 은닉층들은 여러 개의 퍼셉트론처럼 작동하며, AND, OR, NAND 같은 단순한 경계들을 조합하여 XOR 문제와 같은 비선형 문제도 효과적으로 해결할 수 있습니다.
                    </p>
                    <div id="mlp-content-container">
                        <!-- MLP content will be injected here by JS -->
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const appData = {
        and: {
            name: 'AND',
            description: '두 입력이 모두 1일 때만 1을 출력합니다. 결정 경계가 (1,1) 점만 다른 클래스로 완벽히 분리하는 것을 볼 수 있습니다. 오류가 0으로 수렴하며 학습에 성공합니다.',
            X: [[0, 0], [0, 1], [1, 0], [1, 1]],
            y: [0, 0, 0, 1],
            errors: [1, 3, 3, 2, 1, 0, 0, 0, 0, 0],
            code: `import numpy as np
# AND 게이트 데이터
X_and = np.array([[0,0],[0,1],[1,0],[1,1]])
y_and = np.array([0,0,0,1])

# 퍼셉트론 모델 훈련 (클래스 정의는 생략)
ppn_and = Perceptron(input_size=2)
ppn_and.train(X_and, y_and)`
        },
        or: {
            name: 'OR',
            description: '두 입력 중 하나라도 1이면 1을 출력합니다. 결정 경계가 (0,0) 점만 다른 클래스로 분리하며, 오류 없이 학습에 성공합니다.',
            X: [[0, 0], [0, 1], [1, 0], [1, 1]],
            y: [0, 1, 1, 1],
            errors: [1, 2, 1, 0, 0, 0, 0, 0, 0, 0],
            code: `import numpy as np
# OR 게이트 데이터
X_or = np.array([[0,0],[0,1],[1,0],[1,1]])
y_or = np.array([0,1,1,1])

# 퍼셉트론 모델 훈련
ppn_or = Perceptron(input_size=2)
ppn_or.train(X_or, y_or)`
        },
        nand: {
            name: 'NAND',
            description: '두 입력이 모두 1일 때만 0을 출력합니다. AND와 반대 방향의 결정 경계를 가지며, 마찬가지로 학습에 성공합니다.',
            X: [[0, 0], [0, 1], [1, 0], [1, 1]],
            y: [1, 1, 1, 0],
            errors: [2, 3, 3, 0, 0, 0, 0, 0, 0, 0],
            code: `import numpy as np
# NAND 게이트 데이터
X_nand = np.array([[0,0],[0,1],[1,0],[1,1]])
y_nand = np.array([1,1,1,0])

# 퍼셉트론 모델 훈련
ppn_nand = Perceptron(input_size=2)
ppn_nand.train(X_nand, y_nand)`
        },
        xor: {
            name: 'XOR',
            description: '<strong class="text-red-600">학습 실패:</strong> XOR 문제는 두 클래스가 X자 형태로 얽혀있어, 단 하나의 직선으로는 이들을 나눌 수 없습니다. 따라서 오류가 0으로 수렴하지 못하고 계속 발생하며, 결정 경계가 두 클래스를 제대로 분리하지 못하는 것을 확인할 수 있습니다. 이것이 단일 퍼셉트론의 명백한 한계입니다.',
            X: [[0, 0], [0, 1], [1, 0], [1, 1]],
            y: [0, 1, 1, 0],
            errors: [2, 3, 4, 4, 4, 4, 4, 4, 4, 4],
            code: `import numpy as np
# XOR 게이트 데이터
X_xor = np.array([[0,0],[0,1],[1,0],[1,1]])
y_xor = np.array([0,1,1,0])

# 퍼셉트론 모델 훈련 (실패)
ppn_xor = Perceptron(input_size=2)
ppn_xor.train(X_xor, y_xor)`
        },
        mlp: {
            name: 'XOR with MLP',
            description: '<strong class="text-green-700">학습 성공:</strong> MLP는 비선형 결정 경계를 성공적으로 학습했습니다. 손실(loss) 값이 0에 가깝게 수렴하며, 복잡한 곡선 경계가 두 클래스를 완벽히 분리하는 것을 확인할 수 있습니다.',
            loss: [0.8091, 0.7159, 0.6959, 0.7019, 0.6989, 0.6821, 0.6606, 0.6430, 0.6324, 0.6254, 0.6160, 0.6006, 0.5795, 0.5553, 0.5312, 0.5086, 0.4866, 0.4630, 0.4368, 0.4083, 0.3786, 0.3493, 0.3213, 0.2950, 0.2702, 0.2464, 0.2235, 0.2019, 0.1818, 0.1635, 0.1472, 0.1328, 0.1200, 0.1086, 0.0983, 0.0891, 0.0808, 0.0734, 0.0667, 0.0609, 0.0558, 0.0513, 0.0474, 0.0440, 0.0411, 0.0384, 0.0361, 0.0340, 0.0322, 0.0305, 0.0290, 0.0276, 0.0263, 0.0252, 0.0241, 0.0231, 0.0222, 0.0214, 0.0206, 0.0198, 0.0191, 0.0185, 0.0178, 0.0172, 0.0167, 0.0162, 0.0157, 0.0152, 0.0147, 0.0143, 0.0139, 0.0136, 0.0132, 0.0129, 0.0126, 0.0122, 0.0120, 0.0117, 0.0114, 0.0111, 0.0109, 0.0106, 0.0104, 0.0102, 0.0100, 0.0098, 0.0096, 0.0094, 0.0092, 0.0090, 0.0089, 0.0087, 0.0086, 0.0084, 0.0083, 0.0081, 0.0080, 0.0078, 0.0077, 0.0076, 0.0075, 0.0074, 0.0072, 0.0071, 0.0070, 0.0069, 0.0068, 0.0067, 0.0066, 0.0065, 0.0064, 0.0063, 0.0062, 0.0061, 0.0060],
            code: `import numpy as np
from sklearn.neural_network import MLPClassifier

# XOR 데이터
X = np.array([[0,0], [0,1], [1,0], [1,1]])
y = np.array([0, 1, 1, 0])

# MLP 모델 정의 및 훈련
mlp = MLPClassifier(hidden_layer_sizes=(4,),
                    activation='tanh',
                    solver='adam',
                    learning_rate_init=0.1,
                    max_iter=1000,
                    random_state=42)
mlp.fit(X, y)`
        }
    };

    const contentContainer = document.getElementById('content-container');
    const mlpContentContainer = document.getElementById('mlp-content-container');
    const tabButtons = document.querySelectorAll('.tab-btn');
    let charts = {};

    function createContentHTML(key) {
        const d = appData[key];
        const isMlp = key === 'mlp';
        const boundaryChartHtml = isMlp ? `<img src="model1.png" alt="MLP Decision Boundary for XOR Gate">` : `<canvas id="chart-boundary-${key}"></canvas>`;
        const errorChartId = isMlp ? 'chart-loss-mlp' : `chart-error-${key}`;

        return `
            <div id="content-${key}" class="content-section">
                <p class="text-slate-600 mb-8 text-center">${d.description}</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                    <div class="chart-container">${boundaryChartHtml}</div>
                    <div class="chart-container"><canvas id="${errorChartId}"></canvas></div>
                </div>
                <div class="text-center mt-8">
                    <button id="btn-code-${key}" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-lg transition-colors">코드 보기</button>
                    <div id="code-block-${key}" class="code-block mt-4 text-left"><pre><code>${d.code.trim()}</code></pre></div>
                </div>
            </div>`;
    }

    function renderContent(key) {
        if (charts[key]) {
            if(charts[key].boundary) charts[key].boundary.destroy();
            if(charts[key].error) charts[key].error.destroy();
        }
        
        document.querySelectorAll('#content-container .content-section').forEach(el => el.style.display = 'none');
        
        let container = document.getElementById(`content-${key}`);
        if (!container) {
            contentContainer.insertAdjacentHTML('beforeend', createContentHTML(key));
            container = document.getElementById(`content-${key}`);
        }
        container.style.display = 'block';

        const d = appData[key];
        charts[key] = {};
        
        if (key !== 'mlp') {
            charts[key].boundary = createDecisionBoundaryChart(key, d);
        }
        charts[key].error = createErrorChart(key, d);
        
        document.getElementById(`btn-code-${key}`).onclick = () => {
            document.getElementById(`code-block-${key}`).classList.toggle('code-block-visible');
        };
    }
    
    function createDecisionBoundaryChart(key, d) {
        const ctx = document.getElementById(`chart-boundary-${key}`).getContext('2d');
        const pointsClass0 = d.X.filter((_, i) => d.y[i] === 0).map(p => ({x: p[0], y: p[1]}));
        const pointsClass1 = d.X.filter((_, i) => d.y[i] === 1).map(p => ({x: p[0], y: p[1]}));

        let lineData;
        if (key === 'and') lineData = [{x: 0.5, y: 1.5}, {x: 1.5, y: 0.5}];
        else if (key === 'or') lineData = [{x: -0.5, y: 0.5}, {x: 0.5, y: -0.5}];
        else if (key === 'nand') lineData = [{x: 1.5, y: 0.5}, {x: 0.5, y: 1.5}];
        else if (key === 'xor') lineData = [{x: -0.5, y: -0.5}, {x: 1.5, y: 1.5}];

        return new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'Class 0', data: pointsClass0, backgroundColor: 'rgba(239, 68, 68, 0.7)', pointRadius: 8, pointHoverRadius: 10 },
                    { label: 'Class 1', data: pointsClass1, backgroundColor: 'rgba(59, 130, 246, 0.7)', pointRadius: 8, pointHoverRadius: 10 },
                    { label: 'Decision Boundary', data: lineData, type: 'line', borderColor: '#16a34a', borderWidth: 2.5, fill: false, pointRadius: 0, tension: 0 }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: { x: { min: -0.5, max: 1.5, grid: { color: '#e2e8f0' } }, y: { min: -0.5, max: 1.5, grid: { color: '#e2e8f0' } } },
                plugins: { title: { display: true, text: `${d.name.toUpperCase()} Gate Decision Boundary`, font: { size: 16 } }, legend: { position: 'bottom' } }
            }
        });
    }
    
    function createErrorChart(key, d) {
        const isMlp = key === 'mlp';
        const chartId = isMlp ? 'chart-loss-mlp' : `chart-error-${key}`;
        const errorData = isMlp ? d.loss : d.errors;
        const label = isMlp ? 'Loss' : 'Number of Errors';
        const title = isMlp ? 'MLP Loss Curve (XOR)' : `Perceptron Learning Error (${d.name.toUpperCase()} Gate)`;

        const ctx = document.getElementById(chartId).getContext('2d');
        return new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array.from({length: errorData.length}, (_, i) => i + 1),
                datasets: [{ label: label, data: errorData, borderColor: '#ca8a04', backgroundColor: 'rgba(202, 138, 4, 0.2)', fill: true, tension: 0.1, pointRadius: isMlp ? 0 : 3, pointHoverRadius: 5 }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: { x: { title: { display: true, text: 'Epochs' }, grid: { color: '#e2e8f0' } }, y: { title: { display: true, text: label }, beginAtZero: true, grid: { color: '#e2e8f0' } } },
                plugins: { title: { display: true, text: title, font: { size: 16 } }, legend: { display: false } }
            }
        });
    }

    tabButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            e.currentTarget.classList.add('active');
            const key = e.currentTarget.id.replace('btn-', '');
            renderContent(key);
        });
    });

    function renderMlp() {
        if (!document.getElementById('content-mlp')) {
            mlpContentContainer.innerHTML = createContentHTML('mlp');
            document.getElementById(`content-mlp`).style.display = 'block';
            const d_mlp = appData['mlp'];
            charts['mlp'] = {
                error: createErrorChart('mlp', d_mlp)
            };
             document.getElementById(`btn-code-mlp`).onclick = () => {
                document.getElementById(`code-block-mlp`).classList.toggle('code-block-visible');
            };
        }
    }

    renderContent('and');
    renderMlp();
});
</script>

</body>
</html>
