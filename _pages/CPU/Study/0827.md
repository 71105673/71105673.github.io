---
title: "RV32I-APB Day-1"
date: "2025-08-27"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

# 🚌 APB (Advanced Peripheral Bus)와 RV32I 연동

## 1. APB란?
- **AMBA(Advanced Microcontroller Bus Architecture)** 의 하위 버스 프로토콜 중 하나
- 주로 **저속 주변장치**(Timer, UART, GPIO, I2C 등)와 CPU를 연결할 때 사용
- 단순한 버스 구조 → 낮은 전력 소모, 구현이 쉬움
- 단일 클럭 도메인에서 동작 (단순하고 예측 가능)

---

## 2. APB의 주요 신호
- **PADDR** : 주소 (CPU → 주변장치)
- **PWDATA** : 쓰기 데이터 (CPU → 주변장치)
- **PRDATA** : 읽기 데이터 (주변장치 → CPU)
- **PSEL** : 주변장치 선택 신호 (Decoder 출력)
- **PENABLE** : 전송 활성화 신호
- **PWRITE** : Read(0) / Write(1) 구분
- **PCLK, PRESETn** : 클럭과 리셋

---

## 3. 동작 사이클
1. **Setup 단계**
   - CPU가 `PADDR`, `PWDATA`, `PWRITE`, `PSEL` 값을 설정
2. **Enable 단계**
   - `PENABLE` 신호가 High → 유효한 전송
   - Write : 데이터가 주변장치에 저장됨  
   - Read  : `PRDATA`를 CPU가 읽음
3. **Transfer 완료**
   - 사이클 종료 후 다음 전송 준비

---

## 4. RV32I + APB 연동 방식
- **RV32I CPU** 는 메모리 맵 방식으로 주변장치 접근
- **주소 디코더**가 CPU의 주소 버스를 해석해 특정 APB Slave 선택
- APB 프로토콜을 통해 해당 주변장치와 데이터 송수신

### 예시 흐름
- CPU가 GPIO 레지스터에 `0x01`을 쓰고 싶을 때:
  1. CPU → `주소(0x4000_0000)`, `데이터(0x01)`, `PWRITE=1` 전송
  2. Decoder → 해당 주소의 Slave(GPIO) 선택, `PSEL=1`
  3. Enable 단계 → `PWDATA`가 GPIO 레지스터에 기록됨

- CPU가 UART 상태 레지스터를 읽고 싶을 때:
  1. CPU → `주소(0x4000_1000)`, `PWRITE=0` 전송
  2. Decoder → UART Slave 선택
  3. Enable 단계 → UART의 상태 값이 `PRDATA`로 CPU에 반환됨

---

## 5. 정리
- **APB**는 RV32I CPU와 저속 주변장치를 연결하기 위한 간단한 버스 구조
- 주소/데이터 Bus + Chip Enable(Decoder) + Read/Write 신호로 제어
- RV32I의 메모리 맵 구조와 잘 맞아떨어져, UART, Timer, GPIO 등을 쉽게 확장 가능

![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093109.png>)

**신호**를 통해 제어 

![alt text](<../../../assets/img/CPU/APB/화면 캡처 2025-08-27 094736.png>)

## Memory Mapped I/O (CPU와 메모리/주변장치 간 통신 원리)

### 1. RAM에 Write 동작
- CPU가 **RAM에 데이터를 쓰고 싶다면** → `주소` + `데이터`를 함께 전달해야 함
- 주의점:
  - **주소 BUS**는 모든 주변장치에 동시에 연결됨
  - **데이터 BUS**도 마찬가지로 모든 주변장치에 동시에 연결됨
- 따라서 단순히 주소/데이터만 보낸다고 해서 RAM만 동작하지 않음

---

### 2. 특정 장치만 동작시키는 방법 → **디코더(Decoder)**
- **디코더의 출력**을 각 장치의 `Chip Enable (Chip Select)` 핀에 연결
- 특정 주소 구간이 선택되면 → 해당 주변장치만 동작
- **CE 핀(Chip Enable)** 이 활성화되어야 해당 장치가 동작

---

### 3. 장치별 제어 예시
- **ROM Read**
  - CPU가 주소와 제어 신호(Read)를 보냄
  - ROM의 `Chip Enable`이 활성화된 경우에만 데이터 출력
- **RAM Write**
  - 주소 + 데이터 + Write 제어 신호
  - RAM의 `Chip Enable`이 활성화된 경우에만 데이터 저장
- **I/O Write**
  - 주소 + 데이터 + Output 제어 신호
  - I/O 장치의 `Chip Enable`이 활성화된 경우에만 출력 발생

---

✅ 정리  
CPU는 **주소와 데이터**를 버스로 전달하고,  
동시에 **해당 I/O 주소에 맞는 Chip Selector(CE) 신호**를 보내야  
원하는 장치만 동작

![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093556.png>)

1. RAM의 '0'번지에 'A' 값을 Write → CPU에서 0x2000에 'A' Write

2. ROM의 '100'번지 값을 Read →  CPU에서 0x0100 Read

3. I/O의 0x0 번지 값을 Read → CPU에서 0x4000 B 값 Write
   
> 위 동작을 디코터의 Chip Selector 신호가 수행하고 나머지는 확장 가능하다
>
> 같은 Bus 내에서는 하나의 명령어가 수행 되어 하나의 소자가 활동 중이라면 나머지는 비활성화