---
title: "RV32I-APB Day-1"
date: "2025-08-27"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

# APB (Advanced Peripheral Bus)와 RV32I 연동

## 1. Memory Mapped I/O (CPU와 메모리/주변장치 간 통신 원리)
CPU 중심으로 보면 주변 Device는 Memory로 바라본다.

### (1) RAM에 Write 동작
- CPU가 **RAM에 데이터를 쓰고 싶다면** → `주소` + `데이터`를 함께 전달
- 주의:
  - **주소 BUS**와 **데이터 BUS**는 모든 주변장치에 동시에 연결됨
  - 따라서 단순히 주소/데이터만 보낸다고 해서 RAM만 동작하지 않음
---

### (2) 특정 장치만 동작시키는 방법 → **디코더(Decoder)**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093109.png>)
- **디코더 출력**을 각 장치의 `Chip Enable (CE)` 핀에 연결
- 특정 주소 구간이 선택되면 해당 주변장치만 동작
- 즉, **CE 핀 활성화** → 해당 장치 동작
- Broad Casting을 하여도 Decoder에 의해 하나의 장치만 Chip Enable 되어 동작한다.
---

### (3) 장치별 제어 예시
![alt text](<../../../assets/img/CPU/APB/화면 캡처 2025-08-27 094736.png>)
- **ROM Read**
  - CPU가 주소 + Read 신호 보냄 → `CE=1` → ROM만 데이터 출력
- **RAM Write**
  - CPU가 주소 + 데이터 + Write 신호 보냄 → `CE=1` → RAM만 데이터 저장
- **I/O Write**
  - CPU가 주소 + 데이터 + Output 신호 보냄 → `CE=1` → 해당 I/O만 출력 발생
  
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 103550.png>)

## 메모리 용량 계산 -> Memory Map으로 그림

![alt text](<../../../assets/img/CPU/APB/화면 캡처 2025-08-27 103715.png>)

- 주소선: **A12 ~ A0** → 총 13비트
- 주소 공간:  
  $2^{13} \; \text{Bit} = 8192 \; \text{주소}$  

- Byte 단위 변환:  
  $2^{13} \; \text{주소} = 2^{10} \; \text{Byte} = 1 \; \text{KByte}$  

- 따라서 **ROM, RAM, 8255 각각 1KB 공간**이 할당됨

> **8255(I/O)** 의 경우 Address [1:0]까지밖에 없음 
따라서 **0x4000 ~ 0x4003** 까지만 가능

### C에서 주소에 값 할당하기
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 105126.png>)
---

### 예제 동작 시나리오
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093556.png>)
1. **RAM Write**  
   - RAM의 `0번지`에 'A' 저장 → CPU에서 `0x2000`에 'A' Write
2. **ROM Read**  
   - ROM의 `100번지` 값 읽기 → CPU에서 `0x0100` Read
3. **I/O Write**  
   - I/O의 `0x0번지`에 값 쓰기 → CPU에서 `0x4000`에 'B' Write

> 모든 동작은 **디코더의 Chip Selector 신호**에 의해 특정 장치만 활성화됨.  
> 같은 Bus 내에서는 한 번에 하나의 장치만 동작하고, 나머지는 비활성화됨.

## 2. APB란?
- **AMBA(Advanced Microcontroller Bus Architecture)** 의 하위 버스 프로토콜 중 하나
- 주로 **저속 주변장치**(Timer, UART, GPIO, I2C 등)와 CPU를 연결할 때 사용
- 단순한 버스 구조 → 낮은 전력 소모, 구현이 쉬움
- 단일 클럭 도메인에서 동작 (단순하고 예측 가능)
  
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 113153.png>)

하단 그림과 같이 값을 할당해본다.

![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 113626.png>)

**Read, Write Port가** 하나씩 더 있어서 마지막에 **MUX로 Select**

## 3. APB의 주요 신호
- **PADDR** : 주소 (CPU → 주변장치)
- **PWDATA** : 쓰기 데이터 (CPU → 주변장치)
- **PRDATA** : 읽기 데이터 (주변장치 → CPU)
- **PSEL** : 주변장치 선택 신호 (Decoder 출력)
- **PENABLE** : 전송 활성화 신호
- **PWRITE** : Read(0) / Write(1) 구분
- **PCLK, PRESETn** : 클럭과 리셋

## 4. 동작 사이클
1. **Setup 단계**
   - CPU가 `PADDR`, `PWDATA`, `PWRITE`, `PSEL` 값을 설정
2. **Enable 단계**
   - `PENABLE` 신호가 High → 유효한 전송
   - Write : 데이터가 주변장치에 저장됨  
   - Read  : `PRDATA`를 CPU가 읽음
3. **Transfer 완료**
   - 사이클 종료 후 다음 전송 준비

## 5. RV32I + APB 연동 방식
- **RV32I CPU** 는 메모리 맵 방식으로 주변장치 접근
- **주소 디코더**가 CPU의 주소 버스를 해석해 특정 APB Slave 선택
- APB 프로토콜을 통해 해당 주변장치와 데이터 송수신

### 예시 흐름

- **GPIO Write**
  1. CPU → `주소(0x4000_0000)`, `데이터(0x01)`, `PWRITE=1` 전송
  2. Decoder → GPIO Slave 선택, `PSEL=1`
  3. Enable 단계 → `PWDATA`가 GPIO 레지스터에 기록됨

- **UART Status Read**
  1. CPU → `주소(0x4000_1000)`, `PWRITE=0` 전송
  2. Decoder → UART Slave 선택
  3. Enable 단계 → UART 상태 값이 `PRDATA`로 CPU에 반환됨
