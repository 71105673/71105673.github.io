---
title: "RV32I-APB Day-1"
date: "2025-08-27"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

# APB (Advanced Peripheral Bus)와 RV32I 연동

## 1. Memory Mapped I/O (CPU와 메모리/주변장치 간 통신 원리)
CPU 중심으로 보면 주변 Device는 Memory로 바라본다.

### (1) RAM에 Write 동작
- CPU가 **RAM에 데이터를 쓰고 싶다면** → `주소` + `데이터`를 함께 전달
- 주의:
  - **주소 BUS**와 **데이터 BUS**는 모든 주변장치에 동시에 연결됨
  - 따라서 단순히 주소/데이터만 보낸다고 해서 RAM만 동작하지 않음
---

### (2) 특정 장치만 동작시키는 방법 → **디코더(Decoder)**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093109.png>)
- **디코더 출력**을 각 장치의 `Chip Enable (CE)` 핀에 연결
- 특정 주소 구간이 선택되면 해당 주변장치만 동작
- 즉, **CE 핀 활성화** → 해당 장치 동작
- Broad Casting을 하여도 Decoder에 의해 하나의 장치만 Chip Enable 되어 동작한다.
---

### (3) 장치별 제어 예시
![alt text](<../../../assets/img/CPU/APB/화면 캡처 2025-08-27 094736.png>)
- **ROM Read**
  - CPU가 주소 + Read 신호 보냄 → `CE=1` → ROM만 데이터 출력
- **RAM Write**
  - CPU가 주소 + 데이터 + Write 신호 보냄 → `CE=1` → RAM만 데이터 저장
- **I/O Write**
  - CPU가 주소 + 데이터 + Output 신호 보냄 → `CE=1` → 해당 I/O만 출력 발생
  
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 103550.png>)

## 메모리 용량 계산 -> Memory Map으로 그림

![alt text](<../../../assets/img/CPU/APB/화면 캡처 2025-08-27 103715.png>)

- 주소선: **A12 ~ A0** → 총 13비트
- 주소 공간:  
  $2^{13} \; \text{Bit} = 8192 \; \text{주소}$  

- Byte 단위 변환:  
  $2^{13} \; \text{주소} = 2^{10} \; \text{Byte} = 1 \; \text{KByte}$  

- 따라서 **ROM, RAM, 8255 각각 1KB 공간**이 할당됨

> **8255(I/O)** 의 경우 Address [1:0]까지밖에 없음 
따라서 **0x4000 ~ 0x4003** 까지만 가능

### C에서 주소에 값 할당하기
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 105126.png>)
---

### 예제 동작 시나리오
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 093556.png>)
1. **RAM Write**  
   - RAM의 `0번지`에 'A' 저장 → CPU에서 `0x2000`에 'A' Write
2. **ROM Read**  
   - ROM의 `100번지` 값 읽기 → CPU에서 `0x0100` Read
3. **I/O Write**  
   - I/O의 `0x0번지`에 값 쓰기 → CPU에서 `0x4000`에 'B' Write

> 모든 동작은 **디코더의 Chip Selector 신호**에 의해 특정 장치만 활성화됨.  
> 같은 Bus 내에서는 한 번에 하나의 장치만 동작하고, 나머지는 비활성화됨.



---



## 2. APB란?
- **AMBA(Advanced Microcontroller Bus Architecture)** 의 하위 버스 프로토콜 중 하나
- 주로 **저속 주변장치**(Timer, UART, GPIO, I2C 등)와 CPU를 연결할 때 사용
- 단순한 버스 구조 → 낮은 전력 소모, 구현이 쉬움
- 단일 클럭 도메인에서 동작 (단순하고 예측 가능)
- Synchronous Protocol
- Complete 까지 2Cycle 걸림
- Not PipeLine
- Register에 Read or Write 동작을 하게 됨

**APB => Not PipeLine,  AHB => PipeLine**

### Block Diagram
  
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 113153.png>)

하단 그림과 같이 값을 할당해본다.

![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 113626.png>)

**Read, Write Port가** 하나씩 더 있어서 마지막에 **MUX로 Select**

### Cortex-M3 구조
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 114953.png>)

## 3. APB의 주요 신호
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 122827.png>)
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 122834.png>)
- **PCLK** : APB 동작 클럭
- **PADDR** : 주소 (CPU → 주변장치)
- **PWRITE** : 전송 방향 제어 (0 = Read, 1 = Write)
- **PSEL** : 슬레이브 선택 신호 (Decoder 출력)
- **PENABLE** : 전송 활성화 신호 (Enable 단계에서 High)
- **PWDATA** : 쓰기 데이터 (CPU → 주변장치)
- **PREADY** : 슬레이브 응답 신호 (전송 완료 여부 알림)

## 4. 동작 사이클 및 State Diagram
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 122659.png>)

### Diagram
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 124448.png>)

ACCESS 에서 PENABLE이 L->H 되는 순간, Slave에서 PREADY를 L->H
가 되며, Master에서 CPU에 ready를 High로 올린다.

### **APB Write Transfer (Write)**

**Write transfer with no wait states**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 124914.png>)

**Write transfer with wait states**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 125221.png>)

APB의 Write 동작 과정은 다음과 같다.

### **Write without Wait State**

아래 상태 전이는 **IDLE → SETUP → ACCESS → IDLE** 순서로 진행된다.

1. **IDLE 상태 (T0~T1)**
    - `PSEL=0`, `PENABLE=0`, `PWDATA`가 유효하지 않은 상태
    - 새로운 전송을 시작하기 전 기본 대기 상태
2. **SETUP 상태 (T1~T2)**
    - 마스터가 슬레이브를 선택(`PSEL=1`)
    - `PADDR`(주소), `PWDATA`(데이터), `PWRITE=1`(쓰기 모드) 설정
    - `PENABLE=0` 유지
3. **ACCESS 상태 (T2~T3)**
    - `PENABLE=1`로 설정됨 → 슬레이브가 데이터를 수락
    - `PWDATA`가 유지된 상태로 `PREADY=1`이면 전송 완료
4. **IDLE 상태 (T3~T4)**
    - `PSEL=0`, `PENABLE=0`로 변경 → 전송 종료

✅ **요약:**

- `PSEL=1`, `PWRITE=1`로 설정 후 데이터(`PWDATA`)를 슬레이브에 전달
- `PENABLE=1`이 되면서 전송이 진행됨
- `PREADY=1`이면 한 사이클 후 완료, `PREADY=0`이면 대기



### **APB Read Transfer (Read)**
**Read transfer with no wait states**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 125048.png>)

**Read transfer with wait states**
![alt text](<../../../assets/img/CPU/APB/스크린샷 2025-08-27 125317.png>)

읽기 동작의 핵심은 `PWRITE=0` 상태에서 `PRDATA`를 수신하는 것이다.

### **① Read without Wait State**

1. **IDLE 상태 (T0~T1)**
    - 초기 대기 상태
2. **SETUP 상태 (T1~T2)**
    - `PSEL=1`, `PWRITE=0`(읽기 모드), `PADDR` 설정
    - `PENABLE=0` 유지
3. **ACCESS 상태 (T2~T3)**
    - `PENABLE=1`이 되면서 슬레이브가 `PRDATA`에 데이터 제공
    - `PREADY=1`이면 다음 사이클에서 데이터 수신 완료
4. **IDLE 상태 (T3~T4)**
    - `PSEL=0`, `PENABLE=0`로 변경 → 전송 종료

✅ **요약:**

- `PWRITE=0`으로 설정 후 슬레이브가 `PRDATA` 값을 제공
- `PENABLE=1`이 되면 슬레이브가 `PREADY=1` 상태에서 데이터를 반환
- `PREADY=1`이면 데이터 수신 완료

