---
title: "AXI Day-1"
date: "2025-09-04"
thumbnail: "../../../assets/img/CPU/AXI_1/axi.png"
---

# AXI

## AXI 프로토콜 개요
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 115854.png>)
- **마스터와 슬레이브**
  - Arm 프로세서는 **마스터(Master)** 의 예시
  - 메모리 컨트롤러는 **슬레이브(Slave)** 의 간단한 예시

- **AXI 프로토콜의 정의**
  - 마스터와 슬레이브 간 **포인트-투-포인트(point-to-point) 연결**의 신호와 타이밍을 정의
  - **버스(Bus) 규격**이 아닌 **인터페이스 규격**임
  - 따라서, 인터페이스 간의 신호와 타이밍만을 기술

- **인터커넥트 필요성**
  - 각 AXI 마스터 인터페이스는 하나의 AXI 슬레이브 인터페이스에 연결됨
  - 여러 개의 마스터와 슬레이브가 존재하는 경우, **인터커넥트 패브릭(Interconnect Fabric)** 이 필요
  - 이 인터커넥트는 마스터와 슬레이브 인터페이스를 구현하며, AXI 프로토콜도 그 안에서 구현됨

ex) Mater1이 Slave1과 통신할 때, Master2는 Slave3와 통신 가능


## AXI 인터페이스 채널
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 115846.png>)
### 기본 개념
- AXI는 **마스터(Master)** 와 **슬레이브(Slave)** 간의 **포인트-투-포인트 프로토콜**을 정의함
- 각 AXI 인터페이스는 **5개의 주요 채널**을 사용하여 통신함

---

### Write 연산에 사용되는 채널
1. **Write Address (AW) 채널**  
   - 마스터 → 슬레이브 : 쓰기 주소 전달
2. **Write Data (W) 채널**  
   - 마스터 → 슬레이브 : 데이터 전달
3. **Write Response (B) 채널**  
   - 슬레이브 → 마스터 : 쓰기 완료 여부 및 응답 메시지 전달

---

### Read 연산에 사용되는 채널
1. **Read Address (AR) 채널**  
   - 마스터 → 슬레이브 : 읽을 주소 전달
2. **Read Data (R) 채널**  
   - 슬레이브 → 마스터 : 요청한 주소의 데이터 전달  
   - 필요 시 에러 메시지 반환  
     - 예: 잘못된 주소 접근, 데이터 손상, 보안 권한 부족 등

---

### 채널 특성
- 각 채널은 **단방향(Unidirectional)** 으로 동작  
  → 따라서, **Write Response 채널**이 별도로 필요  
  → Read는 별도의 응답 채널 없이 **Read Data 채널**에 응답 포함
- 읽기와 쓰기 모두 **주소 채널과 데이터 채널을 분리**하여 사용  
  → 인터페이스의 대역폭을 극대화할 수 있음
- 읽기 채널과 쓰기 채널 그룹 간에는 **타이밍 의존성이 없음**  
  → 읽기와 쓰기 연산이 **동시에** 진행될 수 있음

---

### 채널별 신호 접두어 (Prefix)
각 채널은 여러 개의 신호로 구성되며, 신호 이름은 채널에 따라 접두어가 붙음:

- **AW** : Write Address 채널 신호  
- **W** : Write Data 채널 신호  
- **B** : Write Response 채널 신호 (**Buffered**)
- **AR** : Read Address 채널 신호  
- **R** : Read Data 채널 신호


## 채널 핸드셰이크 (Channel Handshake)

### 기본 개념
- AXI4 프로토콜의 **5개 채널**은 모두 동일한 **핸드셰이크 메커니즘**을 사용
- 핸드셰이크는 **VALID** 와 **READY** 신호 기반으로 동작
  
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 122124.png>)

Master에서 준 신호를 받으면 Slave가 신호 주는거
---

### 신호 흐름
- **VALID** : **소스(Source) → 목적지(Destination)**
- **READY** : **목적지(Destination) → 소스(Source)**

---

### 소스와 목적지의 역할
- 채널에 따라 마스터/슬레이브가 소스 또는 목적지가 됨  
  - 예:  
    - **Read Address 채널** → 마스터가 소스  
    - **Read Data 채널** → 마스터가 목적지

---

### VALID 신호
- 소스는 전송할 **유효한 정보가 준비됨**을 나타낼 때 VALID를 High로 설정
- 목적지가 데이터를 수신하기 전까지 VALID는 **High 상태를 유지**해야 함  
  → 이렇게 유지되는 신호를 **Sticky Signal** 이라고 부름

---

### READY 신호
- 목적지는 정보를 **수신할 준비가 되었을 때** READY를 High로 설정
- READY는 목적지에서 소스로 전송됨

---

### 클럭 동기화
- 이 메커니즘은 **비동기(asynchronous) 핸드셰이크가 아님**
- 핸드셰이크 완료는 반드시 **클럭의 상승 에지(rising edge)** 에서 이루어짐


## 전송(Transfer)과 트랜잭션(Transaction)의 차이

### 인터커넥트 설계 시 고려사항
- 마스터와 슬레이브의 **성능과 기능**을 파악해야 함
- 이를 통해 성능을 높이기 위해 필요한:
  - **버퍼링(Buffering)**
  - **트래킹(Tracking)**
  - **디코드 로직(Decode Logic)**
  등을 적절히 포함할 수 있음
- 표준 용어를 사용하면 **컴포넌트 간 상호작용** 이해가 쉬워짐

---

### Transfer (전송)
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 123202.png>)
- **단일 정보 교환**을 의미
- 하나의 **VALID–READY 핸드셰이크**로 구성됨
- 즉, 클럭 에지에서 한 번의 데이터 주고받기가 **Transfer**

---

### Transaction (트랜잭션)
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 123417.png>)
- 여러 개의 Transfer가 모여 하나의 Transaction을 형성
- 구성 요소:
  - **주소 전송(Address Transfer)**
  - **하나 이상의 데이터 전송(Data Transfers)**
  - (쓰기의 경우) **응답 전송(Response Transfer)**
- 즉, 버스트(Burst) 단위 전체 흐름이 **Transaction**


## 4.3 채널 전송 예시 (Channel Transfer Examples)

### 기본 개념
- VALID와 READY 신호의 조합에 따라 다양한 핸드셰이크 시퀀스가 가능
- AXI 프로토콜에서는 다음 규칙을 따름:
  - **소스(Source)** : READY가 High가 되기를 기다린 후 VALID를 올리면 안 됨
  - **목적지(Destination)** : VALID가 High가 된 후 READY를 올릴 수 있음
- 따라서 READY는 VALID보다 **먼저**, **나중**, **동시에** asserted 될 수 있음

---
### 예시 1
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 123739.png>)
1. **클럭 사이클 2** : VALID High → 데이터가 유효함을 의미  
2. **클럭 사이클 3** : READY High  
3. **클럭 사이클 4의 상승 에지** : VALID와 READY 모두 High → 핸드셰이크 완료

---

### 예시 2 => 예상되는 값이 올 때 사용 / 1clk 줄임
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 124528.png>)
1. **클럭 사이클 1** : READY High  
2. **클럭 사이클 3** : VALID High  
3. **클럭 사이클 4의 상승 에지** : VALID와 READY 모두 High → 핸드셰이크 완료

보냈으니까(Response가 올거라는 기대) 미리 Ready 신호가 올라간 상태 유지

---

### 예시 3 => 흔치 않은 상황
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 124531.png>)
1. **클럭 사이클 3** : VALID와 READY가 동시에 High  
2. **클럭 사이클 4의 상승 에지** : VALID와 READY 모두 High → 핸드셰이크 완료

---

### 공통 규칙
- **정보 전송 시점** : 클럭 상승 에지에서 VALID와 READY가 모두 High일 때
- 읽기 및 쓰기 핸드셰이크 모두 동일한 규칙을 따라야 함


## Write
![alt text](../../../assets/img/CPU/AXI_1/KakaoTalk_20250904_125108951.png)

## Read
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 125245.png>)




### ->> vs ->
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 125612.png>)

- 화살표 두개 (->>) 의 경우 필수
- 화살표 한개 (->) 의 경우 옵션
  





# AXI4_Lite Block 

## AXI4_Lite Block simple ver
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 140846.png>)

## 세부 정보
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 141904.png>)

## FSM

### MASTER
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 144644.png>)

### MASTER <-> Slave (AW. W, B Channel)
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 153415.png>)


### AXI4_Lite_Master.sv
```verilog
`timescale 1ns / 1ps

module AXI4_Lite_Master (
    // Global signals
    input  logic        ACLK,
    input  logic        ARESETn,
    // WRITE Transaction. AW Channel
    output logic [ 3:0] AWADDR,
    output logic        AWVALID,
    input  logic        AWREADY,
    // WRITE Transaction. W Channel
    output logic [31:0] WDATA,
    output logic        WVALID,
    input  logic        WREADY,
    // WRITE Transaction. B Channel
    input  logic [ 1:0] BRESP,
    input  logic        BVALID,
    output logic        BREADY,
    // READ Transaction. AR Channel
    output logic [ 3:0] ARADDR,
    output logic        ARVALID,
    input  logic        ARREADY,
    // READ Transaction. R Channel
    input  logic [31:0] RADDR,
    input  logic        RVALID,
    output logic        RREADY,
    input  logic [ 1:0] RRESP,
    // Internal Signals
    input  logic [ 3:0] addr,
    input  logic        write,
    input  logic [31:0] wdata,
    output logic [31:0] rdata,
    input  logic        transfer,
    output logic        ready
);
    logic w_ready, r_ready;
    assign ready = (w_ready | r_ready);

    // WRITE Transaction. AW Channel Transfer
    typedef enum {
        AW_IDLE,
        AW_VALID
    } aw_state_e;

    aw_state_e aw_state, aw_state_next;
    logic [3:0] temp_awaddr_reg, temp_awaddr_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            aw_state        <= AW_IDLE;
            temp_awaddr_reg <= 0;
        end else begin
            aw_state        <= aw_state_next;
            temp_awaddr_reg <= temp_awaddr_next;
        end
    end

    always_comb begin
        aw_state_next    = aw_state;
        AWVALID          = 1'b0;
        AWADDR           = temp_awaddr_reg;
        temp_awaddr_next = temp_awaddr_reg;
        case (aw_state)
            AW_IDLE: begin
                AWVALID = 1'b0;
                if (transfer & write) begin
                    aw_state_next    = AW_VALID;
                    temp_awaddr_next = addr;
                end
            end
            AW_VALID: begin
                AWVALID = 1'b1;
                AWADDR  = temp_awaddr_reg;
                if (AWREADY) begin
                    aw_state_next = AW_IDLE;
                end
            end
        endcase
    end

    // WRITE Transaction. W Channel Transfer
    typedef enum {
        W_IDLE,
        W_VALID
    } w_state_e;

    w_state_e w_state, w_state_next;
    logic [31:0] temp_wdata_reg, temp_wdata_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            w_state        <= W_IDLE;
            temp_wdata_reg <= 0;
        end else begin
            w_state        <= w_state_next;
            temp_wdata_reg <= temp_wdata_next;
        end
    end

    always_comb begin
        w_state_next    = w_state;
        WVALID          = 1'b0;
        WDATA           = temp_wdata_reg;
        temp_wdata_next = temp_wdata_reg;
        case (w_state)
            W_IDLE: begin
                WVALID = 1'b0;
                if (transfer & write) begin
                    w_state_next    = W_VALID;
                    temp_wdata_next = wdata;
                end
            end
            W_VALID: begin
                WVALID = 1'b1;
                WDATA  = temp_wdata_reg;
                if (WREADY) begin
                    w_state_next = W_IDLE;
                end
            end
        endcase
    end

    // WRITE Transaction. B Channel Transfer
    typedef enum {
        B_IDLE,
        B_READY
    } b_state_e;

    b_state_e b_state, b_state_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            b_state <= B_IDLE;
        end else begin
            b_state <= b_state_next;
        end
    end

    always_comb begin
        b_state_next = b_state;
        BREADY       = 1'b0;
        w_ready      = 1'b0;
        case (b_state)
            B_IDLE: begin
                BREADY  = 1'b0;
                w_ready = 1'b0;
                if (WVALID) begin
                    b_state_next = B_READY;
                end
            end
            B_READY: begin
                BREADY = 1'b1;
                if (BVALID) begin
                    b_state_next = B_IDLE;
                    w_ready = 1'b1;
                end
            end
        endcase
    end
endmodule
```

### AXI4_Lite_Slave.sv
```verilog
`timescale 1ns / 1ps

module AXI4_Lite_Slave (
    // Global signals
    input  logic        ACLK,
    input  logic        ARESETn,
    // WRITE Transaction. AW Channel
    input  logic [ 3:0] AWADDR,
    input  logic        AWVALID,
    output logic        AWREADY,
    // WRITE Transaction. W Channel
    input  logic [31:0] WDATA,
    input  logic        WVALID,
    output logic        WREADY,
    // WRITE Transaction. B Channel
    output logic [ 1:0] BRESP,
    output logic        BVALID,
    input  logic        BREADY,
    // READ Transaction. AR Channel
    input  logic [ 3:0] ARADDR,
    input  logic        ARVALID,
    output logic        ARREADY,
    // READ Transaction. R Channel
    output logic [31:0] RADDR,
    output logic        RVALID,
    input  logic        RREADY,
    output logic [ 1:0] RRESP
);

    logic [31:0] slv_reg0, slv_reg1, slv_reg2, slv_reg3;

    // WRITE Transaction. AW Channel Transfer
    typedef enum {
        AW_IDLE,
        AW_READY
    } aw_state_e;

    aw_state_e aw_state, aw_state_next;
    logic [3:0] temp_awaddr_reg, temp_awaddr_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            aw_state        <= AW_IDLE;
            temp_awaddr_reg <= 0;
        end else begin
            aw_state        <= aw_state_next;
            temp_awaddr_reg <= temp_awaddr_next;
        end
    end

    always_comb begin
        aw_state_next    = aw_state;
        AWREADY          = 1'b0;
        temp_awaddr_next = temp_awaddr_reg;
        case (aw_state)
            AW_IDLE: begin
                AWREADY = 1'b0;
                if (AWVALID) begin
                    aw_state_next    = AW_READY;
                    temp_awaddr_next = AWADDR;
                end
            end
            AW_READY: begin
                AWREADY          = 1'b1;
                temp_awaddr_next = AWADDR;
                aw_state_next    = AW_IDLE;
            end
        endcase
    end

    // WRITE Transaction. W Channel Transfer
    typedef enum {
        W_IDLE,
        W_READY
    } w_state_e;

    w_state_e w_state, w_state_next;
    logic [31:0] temp_wdata_reg, temp_wdata_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            w_state <= W_IDLE;
        end else begin
            w_state <= w_state_next;
        end
    end

    always_comb begin
        w_state_next = w_state;
        WREADY       = 1'b0;
        case (w_state)
            W_IDLE: begin
                WREADY = 1'b0;
                if (AWVALID) begin
                    w_state_next = W_READY;
                end
            end
            W_READY: begin
                if (WVALID) begin
                    w_state_next = W_IDLE;
                    WREADY = 1'b1;
                    case (temp_awaddr_reg[3:2])
                        2'b00: slv_reg0 = WDATA;
                        2'b01: slv_reg1 = WDATA;
                        2'b10: slv_reg2 = WDATA;
                        2'b11: slv_reg3 = WDATA;
                    endcase
                end
            end
        endcase
    end

    // WRITE Transaction. B Channel Transfer
    typedef enum {
        B_IDLE,
        B_VALID
    } b_state_e;

    b_state_e b_state, b_state_next;

    always_ff @(posedge ACLK, negedge ARESETn) begin
        if (!ARESETn) begin
            b_state <= B_IDLE;
        end else begin
            b_state <= b_state_next;
        end
    end

    always_comb begin
        b_state_next = b_state;
        BVALID       = 1'b0;
        BRESP        = 2'b00;
        case (b_state)
            B_IDLE: begin
                BVALID = 1'b0;
                if (WVALID & WREADY) begin
                    b_state_next = B_VALID;
                end
            end
            B_VALID: begin
                BVALID       = 1'b1;
                BRESP        = 2'b00;
                b_state_next = B_IDLE;
            end
        endcase
    end
endmodule
```

### tb_AXI4_Lite.sv
```verilog
`timescale 1ns / 1ps

module tb_AXI4_Lite ();

    logic        ACLK;
    logic        ARESETn;
    // WRITE Transaction. AW Channel
    logic [ 3:0] AWADDR;
    logic        AWVALID;
    logic        AWREADY;
    // WRITE Transaction. W Channel
    logic [31:0] WDATA;
    logic        WVALID;
    logic        WREADY;
    // WRITE Transaction. B Channel
    logic [ 1:0] BRESP;
    logic        BVALID;
    logic        BREADY;
    // READ Transaction. AR Channel
    logic [ 3:0] ARADDR;
    logic        ARVALID;
    logic        ARREADY;
    // READ Transaction. R Channel
    logic [31:0] RADDR;
    logic        RVALID;
    logic        RREADY;
    logic [ 1:0] RRESP;
    // Internal Signals
    logic [ 3:0] addr;
    logic        write;
    logic [31:0] wdata;
    logic [31:0] rdata;
    logic        transfer;
    logic        ready;

    AXI4_Lite_Master DUT_Master (.*);
    AXI4_Lite_Slave DUT_Slave (.*);

    always #5 ACLK = ~ACLK;

    initial begin
        ACLK = 1'b1;
        ARESETn = 1'b0;
        #10;
        ARESETn = 1'b1;
    end

    task axi_write(input logic [3:0] aix_addr, input logic [31:0] aix_wdata);
        @(posedge ACLK);
        addr = aix_addr;
        write = 1'b1;
        wdata = aix_wdata;
        transfer = 1'b1;
        @(posedge ACLK);
        transfer = 1'b0;
        wait (ready);
    endtask

    initial begin
        repeat (3) @(posedge ACLK);
        axi_write(4'h0, 1);
        axi_write(4'h4, 2);
        axi_write(4'h8, 3);
        axi_write(4'hc, 4);
    end

endmodule
```


### Sim
![alt text](<../../../assets/img/CPU/AXI_1/스크린샷 2025-09-04 161916.png>)

**분석**
![alt text](<../../../assets/img/CPU/AXI_1/화면 캡처 2025-09-04 162245.png>)