---
title: "RV32I-APB Day-2"
date: "2025-08-28"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

# RAM_SLAVE

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input logic clk,
    input logic reset
);
    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire  PCLK = clk;  // APB Clock
    wire  PRESET = reset;  // APB reset 

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;
    logic        PSEL_RAM;  // RAM
    logic        PSEL1;  // GPO
    logic        PSEL2;  // GPI
    logic        PSEL3;  // GPIO
    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA1;  // GPO
    logic [31:0] PRDATA2;  // GPI
    logic [31:0] PRDATA3;  // GPIO
    logic        PREADY_RAM;  // RAM
    logic        PREADY1;  // GPO
    logic        PREADY2;  // GPI
    logic        PREADY3;  // GPIO


    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0  (PSEL_RAM),  // RAM
        .PSEL1  (),  // GPO
        .PSEL2  (),  // GPI
        .PSEL3  (),  // GPIO
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(),  // GPO
        .PRDATA2(),  // GPI
        .PRDATA3(),  // GPIO
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(),  // GPO
        .PREADY2(),  // GPI
        .PREADY3()   // GPIO
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );
endmodule
```

## CPU_RV32I.sv
```verilog
`timescale 1ns / 1ps

module CPU_RV32I (
    input  logic        clk,
    input  logic        reset,
    input  logic [31:0] instrCode,
    output logic [31:0] instrMemAddr,
    output logic        busWe,
    output logic [31:0] busAddr,
    output logic [31:0] busWData,
    input  logic [31:0] busRData,
    output logic        transfer,
    input  logic        ready
);
    logic       PCEn;
    logic       regFileWe;
    logic [3:0] aluControl;
    logic       aluSrcMuxSel;
    logic [2:0] RFWDSrcMuxSel;
    logic       branch;
    logic       jal;
    logic       jalr;

    ControlUnit U_ControlUnit (.*);
    DataPath U_DataPath (.*);
endmodule
```

## ControlUnit.sv
```verilog
`timescale 1ns / 1ps
`include "defines.sv"

module ControlUnit (
    input  logic        clk,
    input  logic        reset,
    input  logic [31:0] instrCode,
    output logic        PCEn,
    output logic        regFileWe,
    output logic [ 3:0] aluControl,
    output logic        aluSrcMuxSel,
    output logic        busWe,
    output logic [ 2:0] RFWDSrcMuxSel,
    output logic        branch,
    output logic        jal,
    output logic        jalr,
    output logic        transfer,
    input  logic        ready
);
    wire  [ 6:0] opcode = instrCode[6:0];
    wire  [ 3:0] operator = {instrCode[30], instrCode[14:12]};
    logic [10:0] signals;
    assign {PCEn, regFileWe, aluSrcMuxSel, busWe, RFWDSrcMuxSel, branch, jal, jalr, transfer} = signals;

    typedef enum {
        FETCH,
        DECODE,
        R_EXE,
        I_EXE,
        B_EXE,
        LU_EXE,
        AU_EXE,
        J_EXE,
        JL_EXE,
        S_EXE,
        S_MEM,
        L_EXE,
        L_MEM,
        L_WB
    } state_e;

    state_e state, next_state;

    always_ff @(posedge clk, posedge reset) begin
        if (reset) begin
            state <= FETCH;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            FETCH:  next_state = DECODE;
            DECODE: begin
                case (opcode)
                    `OP_TYPE_R:  next_state = R_EXE;
                    `OP_TYPE_I:  next_state = I_EXE;
                    `OP_TYPE_B:  next_state = B_EXE;
                    `OP_TYPE_LU: next_state = LU_EXE;
                    `OP_TYPE_AU: next_state = AU_EXE;
                    `OP_TYPE_J:  next_state = J_EXE;
                    `OP_TYPE_JL: next_state = JL_EXE;
                    `OP_TYPE_S:  next_state = S_EXE;
                    `OP_TYPE_L:  next_state = L_EXE;
                endcase
            end
            R_EXE:  next_state = FETCH;
            I_EXE:  next_state = FETCH;
            B_EXE:  next_state = FETCH;
            LU_EXE: next_state = FETCH;
            AU_EXE: next_state = FETCH;
            J_EXE:  next_state = FETCH;
            JL_EXE: next_state = FETCH;
            S_EXE:  next_state = S_MEM;
            S_MEM:  if (ready) next_state = FETCH;
            L_EXE:  next_state = L_MEM;
            L_MEM:  if (ready) next_state = L_WB;
            L_WB:   next_state = FETCH;
        endcase
    end

    always_comb begin
        signals = 11'b0;
        aluControl = `ADD;
        case (state)
            //{PCEn, regFileWe, aluSrcMuxSel, busWe, RFWDSrcMuxSel(3), branch, jal, jalr, transfet} = signals;
            FETCH:  signals = 11'b1_0_0_0_000_0_0_0_0;
            DECODE: signals = 11'b0_0_0_0_000_0_0_0_0;
            R_EXE: begin
                signals = 11'b0_1_0_0_000_0_0_0_0;
                aluControl = operator;
            end
            I_EXE: begin
                signals = 11'b0_1_1_0_000_0_0_0_0;
                if (operator == 4'b1101) aluControl = operator;
                else aluControl = {1'b0, operator[2:0]};
            end
            B_EXE: begin
                signals = 11'b0_0_0_0_000_1_0_0_0;
                aluControl = operator;
            end
            LU_EXE: signals = 11'b0_1_0_0_010_0_0_0_0;
            AU_EXE: signals = 11'b0_1_0_0_011_0_0_0_0;
            J_EXE:  signals = 11'b0_1_0_0_100_0_1_0_0;
            JL_EXE: signals = 11'b0_1_0_0_100_0_1_1_0;
            S_EXE:  signals = 11'b0_0_1_0_000_0_0_0_0;
            S_MEM:  signals = 11'b0_0_1_1_000_0_0_0_1;
            L_EXE:  signals = 11'b0_0_1_0_001_0_0_0_0;
            L_MEM:  signals = 11'b0_0_1_0_001_0_0_0_1;
            L_WB:   signals = 11'b0_1_1_0_001_0_0_0_0;
        endcase
    end
endmodule
```

## APB_Master.sv
```verilog
`timescale 1ns / 1ps

module APB_Master (
    // global signals
    input  logic        PCLK,   // APB Clock
    input  logic        PRESET, // APB reset 
    // APB Interface Signals
    output logic [31:0] PADDR,
    output logic        PWRITE,
    output logic        PENABLE,
    output logic [31:0] PWDATA,
    output logic        PSEL0,      // RAM
    output logic        PSEL1,      // GPO
    output logic        PSEL2,      // GPI
    output logic        PSEL3,      // GPIO

    input  logic [31:0] PRDATA0,    // RAM
    input  logic [31:0] PRDATA1,    // GPO
    input  logic [31:0] PRDATA2,    // GPI
    input  logic [31:0] PRDATA3,    // GPIO

    input  logic        PREADY0,    // RAM
    input  logic        PREADY1,    // GPO
    input  logic        PREADY2,    // GPI
    input  logic        PREADY3,    // GPIO
    // Interanl Interface Signals
    input  logic        transfer,
    output logic        ready,
    input  logic        write,
    input  logic [31:0] addr,
    input  logic [31:0] wdata,
    output logic [31:0] rdata
);

    logic [3:0] pselx;
    logic [1:0] mux_sel;
    logic       decoder_en;
    logic [31:0] temp_addr_reg, temp_addr_next, temp_wdata_reg, temp_wdata_next;
    logic temp_write_reg, temp_write_next;

    assign PSEL0 = pselx[0];
    assign PSEL1 = pselx[1];
    assign PSEL2 = pselx[2];
    assign PSEL3 = pselx[3];

    typedef enum {
        IDLE,
        SETUP,
        ACCESS
    } apb_state_e;

    apb_state_e state, state_next;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            state <= IDLE;
            temp_addr_reg <= 0;
            temp_wdata_reg <= 0;
            temp_write_reg <= 0;
        end else begin
            state <= state_next;
            temp_addr_reg <= temp_addr_next;
            temp_wdata_reg <= temp_wdata_next;
            temp_write_reg <= temp_write_next;
        end
    end

    always_comb begin
        state_next      = state;
        decoder_en      = 1'b0;
        PENABLE         = 1'b0;
        temp_addr_next  = temp_addr_reg;
        temp_wdata_next = temp_wdata_reg;
        temp_write_next = temp_write_reg;
        PADDR           = temp_addr_reg;
        PWRITE          = temp_write_reg;
        PWDATA          = temp_wdata_reg;
        case (state)
            IDLE: begin
                decoder_en = 1'b0;  //sel signal 0
                if (transfer) begin
                    state_next = SETUP;
                    temp_addr_next = addr;      //latching
                    temp_wdata_next = wdata;    //latching
                    temp_write_next = write;    //latching
                end
            end
            SETUP: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b0;
                PADDR      = temp_addr_reg;
                PWRITE     = temp_write_reg;
                state_next = ACCESS;
                if (temp_write_reg) begin
                    PWDATA = temp_wdata_reg;
                end
            end
            ACCESS: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b1;
                if (ready) begin
                    state_next = IDLE;
                end
            end
        endcase
    end

    APB_Decoder U_APB_Decoder (
        .en     (decoder_en),
        .sel    (temp_addr_reg),
        .y      (pselx),
        .mux_sel(mux_sel)
    );

    APB_Mux U_APB_Mux (
        .sel   (mux_sel),
        .rdata0(PRDATA0),
        .rdata1(PRDATA1),
        .rdata2(PRDATA2),
        .rdata3(PRDATA3),
        .ready0(PREADY0),
        .ready1(PREADY1),
        .ready2(PREADY2),
        .ready3(PREADY3),
        .rdata (rdata),
        .ready (ready)
    );

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Decoder (
    input  logic        en,
    input  logic [31:0] sel,
    output logic [ 3:0] y,
    output logic [ 1:0] mux_sel
);

    always_comb begin
        y = 4'b0000;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: y = 4'b0001;
                32'h1000_1xxx: y = 4'b0010;
                32'h1000_2xxx: y = 4'b0100;
                32'h1000_3xxx: y = 4'b1000;
            endcase
        end
    end

    always_comb begin
        mux_sel = 2'dx;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: mux_sel = 2'd0;  // RAM
                32'h1000_1xxx: mux_sel = 2'd1;  // GPO
                32'h1000_2xxx: mux_sel = 2'd2;  // GPI
                32'h1000_3xxx: mux_sel = 2'd3;  // GPIO
            endcase
        end
    end

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Mux (
    input  logic [ 1:0] sel,
    input  logic [31:0] rdata0,
    input  logic [31:0] rdata1,
    input  logic [31:0] rdata2,
    input  logic [31:0] rdata3,
    input  logic        ready0,
    input  logic        ready1,
    input  logic        ready2,
    input  logic        ready3,
    output logic [31:0] rdata,
    output logic        ready
);

    always_comb begin
        rdata = 32'b0;
        case (sel)
            2'd0: rdata = rdata0;   // RAM
            2'd1: rdata = rdata1;   // GPO
            2'd2: rdata = rdata2;   // GPI
            2'd3: rdata = rdata3;   // GPIO
        endcase
    end

    always_comb begin
        ready = 1'b0;
        case (sel)
            2'd0: ready = ready0;   // RAM
            2'd1: ready = ready1;   // GPO
            2'd2: ready = ready2;   // GPI
            2'd3: ready = ready3;   // GPIO
        endcase
    end
endmodule
```

## APB_Slave.sv
```verilog
`timescale 1ns / 1ps

module APB_Slave (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 3:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY
);
    logic [31:0] slv_reg0, slv_reg1, slv_reg2, slv_reg3;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
            slv_reg2 <= 0;
            slv_reg3 <= 0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin
                    case (PADDR[3:2])
                        2'd0: slv_reg0 <= PWDATA; 
                        2'd1: slv_reg1 <= PWDATA;
                        2'd2: slv_reg2 <= PWDATA;
                        2'd3: slv_reg3 <= PWDATA; 
                    endcase
                end else begin  //write 아니고 read일 때
                    case (PADDR[3:2])
                        2'd0: PRDATA <= slv_reg0; 
                        2'd1: PRDATA <= slv_reg1;
                        2'd2: PRDATA <= slv_reg2;
                        2'd3: PRDATA <= slv_reg3; 
                    endcase
                end
            end
        end
    end
endmodule
```

## RAM.sv
```verilog
`timescale 1ns / 1ps

module RAM (
    //Global Signals
    input  logic        PCLK,
    input  logic        PRESET,
    // APB Interface Signals
    input  logic [ 5:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY
);
    logic [31:0] mem[0:2**4-1];  // 0x00 ~ 0x0f => 0x10 * 4 => 0x40

    always_ff @(posedge PCLK) begin
        PREADY <= 1'b0;
        if (PSEL && PENABLE) begin
            PREADY <= 1'b1;
            if (PWRITE) begin
                mem[PADDR[3:2]] <= PWDATA;
            end else begin
                PRDATA <= mem[PADDR[3:2]];
            end
        end
    end
endmodule
```
## Simulation
```verilog
`timescale 1ns / 1ps

module tb_apb ();
    //Global Signals
    logic        PCLK;
    logic        PRESET;

    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;
    logic        PSEL0;
    logic        PSEL1;
    logic        PSEL2;
    logic        PSEL3;
    logic [31:0] PRDATA0;
    logic [31:0] PRDATA1;
    logic [31:0] PRDATA2;
    logic [31:0] PRDATA3;
    logic        PREADY0;
    logic        PREADY1;
    logic        PREADY2;
    logic        PREADY3;
    logic        PREADY;
    logic        PSEL;
    logic [31:0] PRDATA;
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    APB_Master U_APB_Master (.*);

    RAM U_RAM (
        .*,
        .PADDR (PADDR[11:0]),
        .PSEL  (PSEL0),
        .PRDATA(PRDATA0),
        .PREADY(PREADY0)
    );

    APB_Slave U_APB_Slave1 (
        .*,
        .PSEL  (PSEL1),
        .PRDATA(PRDATA1),
        .PREADY(PREADY1)
    );

    APB_Slave U_APB_Slave2 (
        .*,
        .PSEL  (PSEL2),
        .PRDATA(PRDATA2),
        .PREADY(PREADY2)
    );

    always #5 PCLK = ~PCLK;

    initial begin
        PCLK   = 0;
        PRESET = 1;
        #10;
        PRESET = 0;
    end

    task automatic apb_write(input logic [31:0] apb_addr, input logic [31:0] apb_wdata);
        @(posedge PCLK);
        #1;
        write = 1;
        addr = apb_addr;
        wdata = apb_wdata;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait(ready);
    endtask  

    task automatic apb_read(input logic [31:0] apb_addr);
        @(posedge PCLK);
        #1;
        write = 0;
        addr = apb_addr;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait(ready);
    endtask

    initial begin
        #10;
        apb_write(32'h1000_0000, 32'd1);
        apb_write(32'h1000_0004, 32'd2);
        apb_write(32'h1000_0008, 32'd3);

        apb_read(32'h1000_0000);
        apb_read(32'h1000_0004);
        apb_read(32'h1000_0008);

        @(posedge PCLK);
        #1;
        write = 1;
        addr = 32'h1000_1000;
        wdata = 32'd11;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait (ready);

        @(posedge PCLK);
        #1;
        write = 1;
        addr = 32'h1000_2000;
        wdata = 32'd12;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait (ready);

        // @(posedge PCLK);
        // #1;
        // write = 1;
        // addr = 32'h1000_3000;
        // wdata = 32'd20;
        // transfer = 1;
        // @(posedge PCLK);
        // #1;
        // transfer = 0;
        // wait (ready);

        // @(posedge PCLK);
        // #1;
        // write = 0;
        // addr = 32'h1000_3000;
        // transfer = 1;
        // @(posedge PCLK);
        // #1;
        // transfer = 0;
        // wait (ready);

        #50;
        $finish;
    end
endmodule
```

다음과 같이 Task를 활용한다.

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 101656.png>)

READ Write 동작을 확인 가능 

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 101608.png>)


### Top을 MCU로 시뮬
![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 115616.png>)
또한 C-> Assembly 할 때, 0x10001000으로 초기화(SP 주소)

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 115548.png>)

---

# GPO

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 123819.png>)

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input  logic       clk,
    input  logic       reset,
    // External Port
    output logic [7:0] gpo
);
    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire         PCLK = clk;  // APB Clock
    wire         PRESET = reset;  // APB reset 

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;

    logic        PSEL_RAM;  // RAM
    logic        PSEL_GPO;  // GPO
    logic        PSEL2;  // GPI
    logic        PSEL3;  // GPIO

    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA_GPO;  // GPO
    logic [31:0] PRDATA2;  // GPI
    logic [31:0] PRDATA3;  // GPIO

    logic        PREADY_RAM;  // RAM
    logic        PREADY_GPO;  // GPO
    logic        PREADY2;  // GPI
    logic        PREADY3;  // GPIO

    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0(PSEL_RAM),  // RAM
        .PSEL1(PSEL_GPO),  // GPO
        .PSEL2(),  // GPI
        .PSEL3(),  // GPIO
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(PRDATA_GPO),  // GPO
        .PRDATA2(),  // GPI
        .PRDATA3(),  // GPIO
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(PREADY_GPO),  // GPO
        .PREADY2(),  // GPI
        .PREADY3()  // GPIO
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );

    GPO_periph U_GPO_Periph (
        .*,
        .PSEL  (PSEL_GPO),
        .PRDATA(PRDATA_GPO),
        .PREADY(PREADY_GPO)
    );
endmodule
```

## GPO.sv
```verilog
`timescale 1ns / 1ps

module GPO_periph (
    input  logic        PCLK,     // APB Clock
    input  logic        PRESET,   // APB reset 
    // APB Interface Signals
    input  logic [ 2:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // External Port
    output logic [ 7:0] gpo
);
    logic [7:0] cr;
    logic [7:0] odr;

    APB_SlaveInterface_GPO U_APB_SlaveInterface_GPO (.*);
    GPO U_GPO (.*);
endmodule

////////////////////////////////////////////////////////////////////////////////////////////////////

module APB_SlaveInterface_GPO (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 2:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // Internal Port
    output logic [ 7:0] cr,
    output logic [ 7:0] odr
);
    logic [31:0] slv_reg0, slv_reg1;

    assign cr  = slv_reg0;
    assign odr = slv_reg1;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin  //write
                    case (PADDR[2])
                        1'd0: slv_reg0 <= PWDATA;
                        1'd1: slv_reg1 <= PWDATA;
                    endcase
                end else begin  //read
                    case (PADDR[2])
                        1'd0: PRDATA <= slv_reg0;
                        1'd1: PRDATA <= slv_reg1;
                    endcase
                end
            end
        end
    end
endmodule

////////////////////////////////////////////////////////////////////////////////////////////////////

module GPO (
    input  logic [7:0] cr,
    input  logic [7:0] odr,
    output logic [7:0] gpo
);
    genvar i;
    generate
        for (i = 0; i < 8; i++) begin
            assign gpo[i] = cr[i] ? odr[i] : 1'bz;
        end
    endgenerate
endmodule
```

## C to Assembly
![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 143303.png>)
### simulation 
![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 143211.png>)

# GPI

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input  logic       clk,
    input  logic       reset,
    // External Port
    output logic [7:0] gpo,
    input  logic [7:0] gpi
);
    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire         PCLK = clk;  // APB Clock
    wire         PRESET = reset;  // APB reset 

    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;

    logic        PSEL_RAM;  // RAM
    logic        PSEL_GPO;  // GPO
    logic        PSEL_GPI;  // GPI
    logic        PSEL3;  // GPIO

    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA_GPO;  // GPO
    logic [31:0] PRDATA_GPI;  // GPI
    logic [31:0] PRDATA3;  // GPIO

    logic        PREADY_RAM;  // RAM
    logic        PREADY_GPO;  // GPO
    logic        PREADY_GPI;  // GPI
    logic        PREADY3;  // GPIO

    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0(PSEL_RAM),  // RAM
        .PSEL1(PSEL_GPO),  // GPO
        .PSEL2(PSEL_GPI),  // GPI
        .PSEL3(),  // GPIO
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(PRDATA_GPO),  // GPO
        .PRDATA2(PRDATA_GPI),  // GPI
        .PRDATA3(),  // GPIO
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(PREADY_GPO),  // GPO
        .PREADY2(PREADY_GPI),  // GPI
        .PREADY3()  // GPIO
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );

    GPO_periph U_GPO_Periph (
        .*,
        .PSEL  (PSEL_GPO),
        .PRDATA(PRDATA_GPO),
        .PREADY(PREADY_GPO)
    );

    GPI_periph U_GPI_Periph (
        .*,
        .PSEL  (PSEL_GPI),
        .PRDATA(PRDATA_GPI),
        .PREADY(PREADY_GPI)
    );
endmodule
```

## GPI.sv
```verilog
`timescale 1ns / 1ps

module GPI_periph (
    input  logic        PCLK,     // APB Clock
    input  logic        PRESET,   // APB reset 
    // APB Interface Signals
    input  logic [ 2:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // Internal Port
    input  logic [ 7:0] gpi
);

    logic [7:0] cr;
    logic [7:0] idr;

    APB_SlaveInterfcae_GPI U_APB_SlaveInterfcae_GPI (.*);

    GPI U_GPI (.*);

endmodule

///////////////////////////////////////////////////////////

module APB_SlaveInterfcae_GPI (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 2:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // Internal Port
    output logic [ 7:0] cr,
    input  logic [ 7:0] idr
);
    logic [31:0] slv_reg0, slv_reg1;

    assign cr = slv_reg0;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin
                    case (PADDR[2])
                        2'd0: slv_reg0 <= PWDATA;
                        2'd1: ;
                    endcase
                end else begin  //write 아니고 read일 때
                    case (PADDR[2])
                        2'd0: PRDATA <= slv_reg0;
                        2'd1: PRDATA <= idr;
                    endcase
                end
            end
        end
    end
endmodule

/////////////////////////////////////////////////////////////////////////
module GPI (
    input  logic [7:0] cr,
    output logic [7:0] idr,
    input  logic [7:0] gpi
);
    genvar i;
    generate
        for (i = 0; i < 8; i++) begin
            assign idr[i] = cr[i] ? gpi[i] : 1'bz;
        end
    endgenerate
endmodule
```
## C to Assembly
![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 155109.png>)


# GPIO

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 160718.png>)

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input  logic       clk,
    input  logic       reset,
    // External Port
    output logic [7:0] gpo,
    input  logic [7:0] gpi,
    inout  logic [7:0] gpio
);
    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire         PCLK = clk;  // APB Clock
    wire         PRESET = reset;  // APB reset 

    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;

    logic        PSEL_RAM;  // RAM
    logic        PSEL_GPO;  // GPO
    logic        PSEL_GPI;  // GPI
    logic        PSEL_GPIOA;  // GPIO

    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA_GPO;  // GPO
    logic [31:0] PRDATA_GPI;  // GPI
    logic [31:0] PRDATA_GPIOA;  // GPIO

    logic        PREADY_RAM;  // RAM
    logic        PREADY_GPO;  // GPO
    logic        PREADY_GPI;  // GPI
    logic        PREADY_GPIOA;  // GPIO

    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0(PSEL_RAM),  // RAM
        .PSEL1(PSEL_GPO),  // GPO
        .PSEL2(PSEL_GPI),  // GPI
        .PSEL3(PSEL_GPIOA),  // GPIO
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(PRDATA_GPO),  // GPO
        .PRDATA2(PRDATA_GPI),  // GPI
        .PRDATA3(PRDATA_GPIOA),  // GPIO
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(PREADY_GPO),  // GPO
        .PREADY2(PREADY_GPI),  // GPI
        .PREADY3(PREADY_GPIOA)  // GPIO
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );

    GPO_periph U_GPO_Periph (
        .*,
        .PSEL  (PSEL_GPO),
        .PRDATA(PRDATA_GPO),
        .PREADY(PREADY_GPO)
    );

    GPI_periph U_GPI_Periph (
        .*,
        .PSEL  (PSEL_GPI),
        .PRDATA(PRDATA_GPI),
        .PREADY(PREADY_GPI)
    );

    GPIO_periph U_GPIOA (
        .*,
        .PSEL  (PSEL_GPIOA),
        .PRDATA(PRDATA_GPIOA),
        .PREADY(PREADY_GPIOA)
    );
endmodule
```

## GPIO.sv
```verilog
`timescale 1ns / 1ps

module GPIO_periph (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 2:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // External Port
    inout  logic [ 7:0] gpio
);

    logic [7:0] cr;
    logic [7:0] idr;
    logic [7:0] odr;

    APB_SlaveInterfcae_GPIO U_APB_SlaveInterfcae_GPIO (.*);

    GPIO U_GPIO (.*);
endmodule

////////////////////////////////////////////////////////////

module APB_SlaveInterfcae_GPIO (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 3:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // Internal Port
    output logic [ 7:0] cr,
    input  logic [ 7:0] idr,
    output logic [ 7:0] odr
);
    logic [31:0] slv_reg0, slv_reg1, slv_reg2;

    assign cr  = slv_reg0;
    assign odr = slv_reg2;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
            slv_reg2 <= 0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin
                    case (PADDR[3:2])
                        2'd0: slv_reg0 <= PWDATA;
                        2'd1: ;
                        2'd2: slv_reg2 <= PWDATA;
                    endcase
                end else begin  //write 아니고 read일 때
                    case (PADDR[3:2])
                        2'd0: PRDATA <= slv_reg0;
                        2'd1: PRDATA <= idr;
                        2'd2: PRDATA <= slv_reg2;
                    endcase
                end
            end
        end
    end
endmodule

////////////////////////////////////////////////////////////

module GPIO (
    input  logic [7:0] cr,
    output logic [7:0] idr,
    input  logic [7:0] odr,
    inout  logic [7:0] gpio
);
    genvar i;
    generate
        for (i = 0; i < 8; i++) begin
            assign gpio[i] = cr[i] ? odr[i] : 1'bz;
            assign idr[i]  = ~cr[i] ? gpio[i] : 1'bz;
        end
    endgenerate

endmodule
```
## C 
```c
#include <stdint.h>

#define APB_BASE 0x10000000

#define GPO_BASE (APB_BASE + 0x1000)
#define GPO_CR   *(uint32_t *)(GPO_BASE + 0x00)
#define GPO_ODR  *(uint32_t *)(GPO_BASE + 0x04)

#define GPI_BASE (APB_BASE + 0x2000)
#define GPI_CR   *(uint32_t *)(GPI_BASE + 0x00)
#define GPI_IDR  *(uint32_t *)(GPI_BASE + 0x04)

#define GPIO_BASE (APB_BASE + 0x3000)
#define GPIO_CR   *(uint32_t *)(GPIO_BASE + 0x00)
#define GPIO_IDR  *(uint32_t *)(GPIO_BASE + 0x04)
#define GPIO_ODR  *(uint32_t *)(GPIO_BASE + 0x08)

void delay(uint32_t t);

int main()
{
    enum {LEFT, RIGHT};

    uint32_t data = 1;

    GPO_CR  = 0xff;
    GPI_CR  = 0xff;

    GPIO_CR |= 0x0f;
    GPIO_CR &= ~(0x0f<<4);

    uint32_t state = LEFT;

    while(1)
    {
        switch(state)
        {
            case LEFT:
                data = (data >> 7) | (data << 1);
                if (GPIO_IDR & (1<<5)) state = RIGHT;
                break;
            case RIGHT:
                data = (data << 7) | (data >> 1);
                if (GPIO_IDR & (1<<6)) state = LEFT;
                break;
        }
        GPO_ODR = data;
        GPIO_ODR = GPIO_IDR >> 4;
        delay(1000);
        
    }
    return 0;
}

void delay(uint32_t t)
{
    for(uint32_t i = 0; i < t; i++){
        for(uint32_t j=0;j<1000;j++);
    }
}
```


### 결과
<video controls src="../../../assets/img/CPU/APB3/GPIO.mp4" title="Title"></video>


---

# Home Work -> FND 출력하기

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input  logic       clk,
    input  logic       reset,
    // External Port
    output logic [7:0] gpo,
    input  logic [7:0] gpi,
    inout  logic [7:0] gpio,

    output logic [ 3:0] fndCom,
    output logic [ 7:0] fndFont
);
    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire         PCLK = clk;  // APB Clock
    wire         PRESET = reset;  // APB reset 

    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;

    logic        PSEL_RAM;  // RAM
    logic        PSEL_GPO;  // GPO
    logic        PSEL_GPI;  // GPI
    logic        PSEL_GPIOA;  // GPIO
    logic        PSEL_FND;  // FND

    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA_GPO;  // GPO
    logic [31:0] PRDATA_GPI;  // GPI
    logic [31:0] PRDATA_GPIOA;  // GPIO
    logic [31:0] PRDATA_FND;  // FND

    logic        PREADY_RAM;  // RAM
    logic        PREADY_GPO;  // GPO
    logic        PREADY_GPI;  // GPI
    logic        PREADY_GPIOA;  // GPIO
    logic        PREADY_FND;  // FND

    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0(PSEL_RAM),  // RAM
        .PSEL1(PSEL_GPO),  // GPO
        .PSEL2(PSEL_GPI),  // GPI
        .PSEL3(PSEL_GPIOA),  // GPIO
        .PSEL4(PSEL_FND),
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(PRDATA_GPO),  // GPO
        .PRDATA2(PRDATA_GPI),  // GPI
        .PRDATA3(PRDATA_GPIOA),  // GPIO
        .PRDATA4(PRDATA_FND),
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(PREADY_GPO),  // GPO
        .PREADY2(PREADY_GPI),  // GPI
        .PREADY3(PREADY_GPIOA),  // GPIO
        .PREADY4(PREADY_FND)    // FND
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );

    GPO_periph U_GPO_Periph (
        .*,
        .PSEL  (PSEL_GPO),
        .PRDATA(PRDATA_GPO),
        .PREADY(PREADY_GPO)
    );

    GPI_periph U_GPI_Periph (
        .*,
        .PSEL  (PSEL_GPI),
        .PRDATA(PRDATA_GPI),
        .PREADY(PREADY_GPI)
    );

    GPIO_periph U_GPIOA (
        .*,
        .PSEL  (PSEL_GPIOA),
        .PRDATA(PRDATA_GPIOA),
        .PREADY(PREADY_GPIOA)
    );

    FND_Peirph U_FND_Periph(
        .*,
        .PSEL  (PSEL_FND),
        .PRDATA(PRDATA_FND),
        .PREADY(PREADY_FND)
    );
endmodule
```
## APB_Master.sv
```verilog
`timescale 1ns / 1ps

module APB_Master (
    // global signals
    input  logic        PCLK,   // APB Clock
    input  logic        PRESET, // APB reset 
    // APB Interface Signals
    output logic [31:0] PADDR,
    output logic        PWRITE,
    output logic        PENABLE,
    output logic [31:0] PWDATA,
    output logic        PSEL0,      // RAM
    output logic        PSEL1,      // GPO
    output logic        PSEL2,      // GPI
    output logic        PSEL3,      // GPIO
    output logic        PSEL4,      // FND

    input  logic [31:0] PRDATA0,    // RAM
    input  logic [31:0] PRDATA1,    // GPO
    input  logic [31:0] PRDATA2,    // GPI
    input  logic [31:0] PRDATA3,    // GPIO
    input  logic [31:0] PRDATA4,    // FND

    input  logic        PREADY0,    // RAM
    input  logic        PREADY1,    // GPO
    input  logic        PREADY2,    // GPI
    input  logic        PREADY3,    // GPIO
    input  logic        PREADY4,    // FND
    // Interanl Interface Signals
    input  logic        transfer,
    output logic        ready,
    input  logic        write,
    input  logic [31:0] addr,
    input  logic [31:0] wdata,
    output logic [31:0] rdata
);

    logic [4:0] pselx;
    logic [2:0] mux_sel;
    logic       decoder_en;
    logic [31:0] temp_addr_reg, temp_addr_next, temp_wdata_reg, temp_wdata_next;
    logic temp_write_reg, temp_write_next;

    assign PSEL0 = pselx[0];
    assign PSEL1 = pselx[1];
    assign PSEL2 = pselx[2];
    assign PSEL3 = pselx[3];
    assign PSEL4 = pselx[4];

    typedef enum {
        IDLE,
        SETUP,
        ACCESS
    } apb_state_e;

    apb_state_e state, state_next;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            state <= IDLE;
            temp_addr_reg <= 0;
            temp_wdata_reg <= 0;
            temp_write_reg <= 0;
        end else begin
            state <= state_next;
            temp_addr_reg <= temp_addr_next;
            temp_wdata_reg <= temp_wdata_next;
            temp_write_reg <= temp_write_next;
        end
    end

    always_comb begin
        state_next      = state;
        decoder_en      = 1'b0;
        PENABLE         = 1'b0;
        temp_addr_next  = temp_addr_reg;
        temp_wdata_next = temp_wdata_reg;
        temp_write_next = temp_write_reg;
        PADDR           = temp_addr_reg;
        PWRITE          = temp_write_reg;
        PWDATA          = temp_wdata_reg;
        case (state)
            IDLE: begin
                decoder_en = 1'b0;  //sel signal 0
                if (transfer) begin
                    state_next = SETUP;
                    temp_addr_next = addr;      //latching
                    temp_wdata_next = wdata;    //latching
                    temp_write_next = write;    //latching
                end
            end
            SETUP: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b0;
                PADDR      = temp_addr_reg;
                PWRITE     = temp_write_reg;
                state_next = ACCESS;
                if (temp_write_reg) begin
                    PWDATA = temp_wdata_reg;
                end
            end
            ACCESS: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b1;
                if (ready) begin
                    state_next = IDLE;
                end
            end
        endcase
    end

    APB_Decoder U_APB_Decoder (
        .en     (decoder_en),
        .sel    (temp_addr_reg),
        .y      (pselx),
        .mux_sel(mux_sel)
    );

    APB_Mux U_APB_Mux (
        .sel   (mux_sel),
        .rdata0(PRDATA0),
        .rdata1(PRDATA1),
        .rdata2(PRDATA2),
        .rdata3(PRDATA3),
        .rdata4(PRDATA4),
        .ready0(PREADY0),
        .ready1(PREADY1),
        .ready2(PREADY2),
        .ready3(PREADY3),
        .ready4(PREADY4),
        .rdata (rdata),
        .ready (ready)
    );

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Decoder (
    input  logic        en,
    input  logic [31:0] sel,
    output logic [ 4:0] y,
    output logic [ 2:0] mux_sel
);

    always_comb begin
        y = 5'b00000;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: y = 5'b00001;
                32'h1000_1xxx: y = 5'b00010;
                32'h1000_2xxx: y = 5'b00100;
                32'h1000_3xxx: y = 5'b01000;
                32'h1000_4xxx: y = 5'b10000;
            endcase
        end
    end

    always_comb begin
        mux_sel = 3'dx;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: mux_sel = 3'd0;  // RAM
                32'h1000_1xxx: mux_sel = 3'd1;  // GPO
                32'h1000_2xxx: mux_sel = 3'd2;  // GPI
                32'h1000_3xxx: mux_sel = 3'd3;  // GPIO
                32'h1000_4xxx: mux_sel = 3'd4;  // FND
            endcase
        end
    end

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Mux (
    input  logic [ 2:0] sel,
    input  logic [31:0] rdata0,
    input  logic [31:0] rdata1,
    input  logic [31:0] rdata2,
    input  logic [31:0] rdata3,
    input  logic [31:0] rdata4,
    input  logic        ready0,
    input  logic        ready1,
    input  logic        ready2,
    input  logic        ready3,
    input  logic        ready4,
    output logic [31:0] rdata,
    output logic        ready
);

    always_comb begin
        rdata = 32'b0;
        case (sel)
            3'd0: rdata = rdata0;   // RAM
            3'd1: rdata = rdata1;   // GPO
            3'd2: rdata = rdata2;   // GPI
            3'd3: rdata = rdata3;   // GPIO
            3'd4: rdata = rdata4;   // FND
        endcase
    end

    always_comb begin
        ready = 1'b0;
        case (sel)
            3'd0: ready = ready0;   // RAM
            3'd1: ready = ready1;   // GPO
            3'd2: ready = ready2;   // GPI
            3'd3: ready = ready3;   // GPIO
            3'd4: ready = ready4;   // FND
        endcase
    end

endmodule
```

## FND_Peirph.sv
```verilog
`timescale 1ns / 1ps

module FND_Peirph(
    // global signals
    input  logic        PCLK,
    input  logic        PRESET,
    // APB Interface Signals
    input  logic [ 3:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,

    output logic [ 3:0] fndCom,
    output logic [ 7:0] fndFont
    );


    logic [13:0] odr;

    APB_SlaveIntf_FND U_APB_SlaveInterf_FND (.*);


    fnd_Controller U_FNDCNTL(
        .clk(PCLK),
        .reset(PRESET),
        .number(odr),
        .fndCom(fndCom),
        .fndFont(fndFont)
    );

endmodule


module APB_SlaveIntf_FND (
    // global signals
    input  logic        PCLK,
    input  logic        PRESET,
    // APB Interface Signals
    input  logic [ 3:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY,
    // Internal Port
    output logic [ 13:0] odr
);

    logic [31:0] slv_reg0;

    assign odr  = slv_reg0[13:0];

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 32'd0;
            PRDATA   <= 32'd0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin
                    case (PADDR[3:2])
                        2'd0: slv_reg0 <= PWDATA;
                    endcase
                end else begin
                    case (PADDR[3:2])
                        2'd0: PRDATA <= slv_reg0;
                    endcase
                end
            end
        end
    end
endmodule
```

## C to Assembly

### C
```C
#include <stdint.h>

#define APB_BASE 0x10000000

#define GPO_BASE (APB_BASE + 0x1000)
#define GPO_CR   *(uint32_t *)(GPO_BASE + 0x00)
#define GPO_ODR  *(uint32_t *)(GPO_BASE + 0x04)

#define GPI_BASE (APB_BASE + 0x2000)
#define GPI_CR   *(uint32_t *)(GPI_BASE + 0x00)
#define GPI_IDR  *(uint32_t *)(GPI_BASE + 0x04)

#define GPIO_BASE (APB_BASE + 0x3000)
#define GPIO_CR   *(uint32_t *)(GPIO_BASE + 0x00)
#define GPIO_IDR  *(uint32_t *)(GPIO_BASE + 0x04)
#define GPIO_ODR  *(uint32_t *)(GPIO_BASE + 0x08)

#define FND_BASE (APB_BASE + 0x4000)
#define FND_DATA   *(uint32_t *)(FND_BASE + 0x00)

void delay(uint32_t t);

int main()
{
    uint32_t data = 0;

    while(1)
    {
        if (data ==9999) data = 0;
        else data += 1;

        FND_DATA = data;
        delay(1000);
    }
    
    return 0;
}

void delay(uint32_t t)
{
    for(uint32_t i = 0; i < t; i++){
        for(uint32_t j=0;j<1000;j++);
    }
}
```

### Assembly
```bash
		li		sp,0x10001000
main:
        addi    sp,sp,-32
        sw      ra,28(sp)
        sw      s0,24(sp)
        addi    s0,sp,32
        sw      zero,-20(s0)
.L4:
        lw      a4,-20(s0)
        li      a5,8192
        addi    a5,a5,1807
        bne     a4,a5,.L2
        sw      zero,-20(s0)
        j       .L3
.L2:
        lw      a5,-20(s0)
        addi    a5,a5,1
        sw      a5,-20(s0)
.L3:
        li      a5,268451840
        lw      a4,-20(s0)
        sw      a4,0(a5)
        li      a0,1000
        call    delay
        j       .L4
delay:
        addi    sp,sp,-48
        sw      ra,44(sp)
        sw      s0,40(sp)
        addi    s0,sp,48
        sw      a0,-36(s0)
        sw      zero,-20(s0)
        j       .L6
.L9:
        sw      zero,-24(s0)
        j       .L7
.L8:
        lw      a5,-24(s0)
        addi    a5,a5,1
        sw      a5,-24(s0)
.L7:
        lw      a4,-24(s0)
        li      a5,999
        bleu    a4,a5,.L8
        lw      a5,-20(s0)
        addi    a5,a5,1
        sw      a5,-20(s0)
.L6:
        lw      a4,-20(s0)
        lw      a5,-36(s0)
        bltu    a4,a5,.L9
        nop
        nop
        lw      ra,44(sp)
        lw      s0,40(sp)
        addi    sp,sp,48
        jr      ra
```

### Disassembly
```bash
0000000000000000 :
   0:	10001137          	lui	sp,0x10001

0000000000000004 
:
   4:	fe010113          	addi	sp,sp,-32 # 10000fe0 <_sstack+0xfff05e0>
   8:	00112e23          	sw	ra,28(sp)
   c:	00812c23          	sw	s0,24(sp)
  10:	02010413          	addi	s0,sp,32
  14:	fe042623          	sw	zero,-20(s0)
  18:	fec42703          	lw	a4,-20(s0)
  1c:	000027b7          	lui	a5,0x2
  20:	70f78793          	addi	a5,a5,1807 # 270f <__stack_size+0x1f0f>
  24:	00f71663          	bne	a4,a5,30 
  28:	fe042623          	sw	zero,-20(s0)
  2c:	0100006f          	j	3c 
  30:	fec42783          	lw	a5,-20(s0)
  34:	00178793          	addi	a5,a5,1
  38:	fef42623          	sw	a5,-20(s0)
  3c:	100047b7          	lui	a5,0x10004
  40:	fec42703          	lw	a4,-20(s0)
  44:	00e7a023          	sw	a4,0(a5) # 10004000 <_sstack+0xfff3600>
  48:	3e800513          	li	a0,1000
  4c:	008000ef          	jal	ra,54 
  50:	fc9ff06f          	j	18 

0000000000000054 :
  54:	fd010113          	addi	sp,sp,-48
  58:	02112623          	sw	ra,44(sp)
  5c:	02812423          	sw	s0,40(sp)
  60:	03010413          	addi	s0,sp,48
  64:	fca42e23          	sw	a0,-36(s0)
  68:	fe042623          	sw	zero,-20(s0)
  6c:	0300006f          	j	9c 
  70:	fe042423          	sw	zero,-24(s0)
  74:	0100006f          	j	84 
  78:	fe842783          	lw	a5,-24(s0)
  7c:	00178793          	addi	a5,a5,1
  80:	fef42423          	sw	a5,-24(s0)
  84:	fe842703          	lw	a4,-24(s0)
  88:	3e700793          	li	a5,999
  8c:	fee7f6e3          	bleu	a4,a5,78 
  90:	fec42783          	lw	a5,-20(s0)
  94:	00178793          	addi	a5,a5,1
  98:	fef42623          	sw	a5,-20(s0)
  9c:	fec42703          	lw	a4,-20(s0)
  a0:	fdc42783          	lw	a5,-36(s0)
  a4:	fcf766e3          	bltu	a4,a5,70 
  a8:	00000013          	nop
  ac:	00000013          	nop
  b0:	02c12083          	lw	ra,44(sp)
  b4:	02812403          	lw	s0,40(sp)
  b8:	03010113          	addi	sp,sp,48
  bc:	00008067          	ret
```

## 동작 영상
<video controls src="../../../assets/img/CPU/APB2/영상.mp4" title="Title"></video>



### 추가 다른 C 코드
```c
#include <stdint.h>

#define APB_BASE 0x10000000

#define GPO_BASE (APB_BASE + 0x1000)
#define GPO_CR   *(uint32_t *)(GPO_BASE + 0x00)
#define GPO_ODR  *(uint32_t *)(GPO_BASE + 0x04)

#define GPI_BASE (APB_BASE + 0x2000)
#define GPI_CR   *(uint32_t *)(GPI_BASE + 0x00)
#define GPI_IDR  *(uint32_t *)(GPI_BASE + 0x04)

#define GPIO_BASE (APB_BASE + 0x3000)
#define GPIO_CR   *(uint32_t *)(GPIO_BASE + 0x00)
#define GPIO_IDR  *(uint32_t *)(GPIO_BASE + 0x04)
#define GPIO_ODR  *(uint32_t *)(GPIO_BASE + 0x08)

#define FND_BASE (APB_BASE + 0x4000)
#define FND_CR   *(uint32_t *)(FND_BASE + 0x00)
#define FND_IDR  *(uint32_t *)(FND_BASE + 0x04)
#define FND_DATA *(uint32_t *)(FND_BASE + 0x08)

void delay(uint32_t t);

int main()
{
    enum {LEFT, RIGHT};

    uint32_t data = 1;

    GPO_CR  = 0xff;
    GPI_CR  = 0xff;

    GPIO_CR |= 0x0f;
    GPIO_CR &= ~(0x0f<<4);

    FND_CR |= 0x0f;
    FND_CR &= ~(0x0f<<4);

    uint32_t state = LEFT;

    while(1)
    {
        switch(state)
        {
            case LEFT:
                data = (data >> 7) | (data << 1);
                if (GPIO_IDR & (1<<5)) state = RIGHT;
                break;
            case RIGHT:
                data = (data << 7) | (data >> 1);
                if (GPIO_IDR & (1<<6)) state = LEFT;
                break;
        }
        GPO_ODR = data;
        //GPIO_ODR = GPIO_IDR >> 4;
        // data = GPI_IDR;
        delay(1000);
        
    }
    return 0;
}

void delay(uint32_t t)
{
    for(uint32_t i = 0; i < t; i++){
        for(uint32_t j=0;j<1000;j++);
    }
}
```
