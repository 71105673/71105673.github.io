---
title: "RV32I-APB Day-2"
date: "2025-08-28"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

# RAM_SLAVE

## MCU.sv
```verilog
`timescale 1ns / 1ps

module MCU (
    input logic clk,
    input logic reset
);
    logic [31:0] instrCode;
    logic [31:0] instrMemAddr;
    logic        busWe;
    logic [31:0] busAddr;
    logic [31:0] busWData;
    logic [31:0] busRData;

    // Internal Interface Signals
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    wire  PCLK = clk;  // APB Clock
    wire  PRESET = reset;  // APB reset 

    // APB Interface Signals
    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;
    logic        PSEL_RAM;  // RAM
    logic        PSEL1;  // GPO
    logic        PSEL2;  // GPI
    logic        PSEL3;  // GPIO
    logic [31:0] PRDATA_RAM;  // RAM
    logic [31:0] PRDATA1;  // GPO
    logic [31:0] PRDATA2;  // GPI
    logic [31:0] PRDATA3;  // GPIO
    logic        PREADY_RAM;  // RAM
    logic        PREADY1;  // GPO
    logic        PREADY2;  // GPI
    logic        PREADY3;  // GPIO


    assign write = busWe;
    assign addr = busAddr;
    assign wdata = busWData;
    assign busRData = rdata;

    ROM U_ROM (
        .addr(instrMemAddr),
        .data(instrCode)
    );

    CPU_RV32I U_RV32I (.*);

    APB_Master U_APB_MASTER (
        .*,
        .PSEL0  (PSEL_RAM),  // RAM
        .PSEL1  (),  // GPO
        .PSEL2  (),  // GPI
        .PSEL3  (),  // GPIO
        .PRDATA0(PRDATA_RAM),  // RAM
        .PRDATA1(),  // GPO
        .PRDATA2(),  // GPI
        .PRDATA3(),  // GPIO
        .PREADY0(PREADY_RAM),  // RAM
        .PREADY1(),  // GPO
        .PREADY2(),  // GPI
        .PREADY3()   // GPIO
    );

    RAM U_RAM (
        .*,
        .PSEL  (PSEL_RAM),
        .PRDATA(PRDATA_RAM),
        .PREADY(PREADY_RAM)
    );
endmodule
```

## CPU_RV32I.sv
```verilog
`timescale 1ns / 1ps

module CPU_RV32I (
    input  logic        clk,
    input  logic        reset,
    input  logic [31:0] instrCode,
    output logic [31:0] instrMemAddr,
    output logic        busWe,
    output logic [31:0] busAddr,
    output logic [31:0] busWData,
    input  logic [31:0] busRData,
    output logic        transfer,
    input  logic        ready
);
    logic       PCEn;
    logic       regFileWe;
    logic [3:0] aluControl;
    logic       aluSrcMuxSel;
    logic [2:0] RFWDSrcMuxSel;
    logic       branch;
    logic       jal;
    logic       jalr;

    ControlUnit U_ControlUnit (.*);
    DataPath U_DataPath (.*);
endmodule
```

## ControlUnit.sv
```verilog
`timescale 1ns / 1ps
`include "defines.sv"

module ControlUnit (
    input  logic        clk,
    input  logic        reset,
    input  logic [31:0] instrCode,
    output logic        PCEn,
    output logic        regFileWe,
    output logic [ 3:0] aluControl,
    output logic        aluSrcMuxSel,
    output logic        busWe,
    output logic [ 2:0] RFWDSrcMuxSel,
    output logic        branch,
    output logic        jal,
    output logic        jalr,
    output logic        transfer,
    input  logic        ready
);
    wire  [ 6:0] opcode = instrCode[6:0];
    wire  [ 3:0] operator = {instrCode[30], instrCode[14:12]};
    logic [10:0] signals;
    assign {PCEn, regFileWe, aluSrcMuxSel, busWe, RFWDSrcMuxSel, branch, jal, jalr, transfer} = signals;

    typedef enum {
        FETCH,
        DECODE,
        R_EXE,
        I_EXE,
        B_EXE,
        LU_EXE,
        AU_EXE,
        J_EXE,
        JL_EXE,
        S_EXE,
        S_MEM,
        L_EXE,
        L_MEM,
        L_WB
    } state_e;

    state_e state, next_state;

    always_ff @(posedge clk, posedge reset) begin
        if (reset) begin
            state <= FETCH;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            FETCH:  next_state = DECODE;
            DECODE: begin
                case (opcode)
                    `OP_TYPE_R:  next_state = R_EXE;
                    `OP_TYPE_I:  next_state = I_EXE;
                    `OP_TYPE_B:  next_state = B_EXE;
                    `OP_TYPE_LU: next_state = LU_EXE;
                    `OP_TYPE_AU: next_state = AU_EXE;
                    `OP_TYPE_J:  next_state = J_EXE;
                    `OP_TYPE_JL: next_state = JL_EXE;
                    `OP_TYPE_S:  next_state = S_EXE;
                    `OP_TYPE_L:  next_state = L_EXE;
                endcase
            end
            R_EXE:  next_state = FETCH;
            I_EXE:  next_state = FETCH;
            B_EXE:  next_state = FETCH;
            LU_EXE: next_state = FETCH;
            AU_EXE: next_state = FETCH;
            J_EXE:  next_state = FETCH;
            JL_EXE: next_state = FETCH;
            S_EXE:  next_state = S_MEM;
            S_MEM:  if (ready) next_state = FETCH;
            L_EXE:  next_state = L_MEM;
            L_MEM:  if (ready) next_state = L_WB;
            L_WB:   next_state = FETCH;
        endcase
    end

    always_comb begin
        signals = 11'b0;
        aluControl = `ADD;
        case (state)
            //{PCEn, regFileWe, aluSrcMuxSel, busWe, RFWDSrcMuxSel(3), branch, jal, jalr, transfet} = signals;
            FETCH:  signals = 11'b1_0_0_0_000_0_0_0_0;
            DECODE: signals = 11'b0_0_0_0_000_0_0_0_0;
            R_EXE: begin
                signals = 11'b0_1_0_0_000_0_0_0_0;
                aluControl = operator;
            end
            I_EXE: begin
                signals = 11'b0_1_1_0_000_0_0_0_0;
                if (operator == 4'b1101) aluControl = operator;
                else aluControl = {1'b0, operator[2:0]};
            end
            B_EXE: begin
                signals = 11'b0_0_0_0_000_1_0_0_0;
                aluControl = operator;
            end
            LU_EXE: signals = 11'b0_1_0_0_010_0_0_0_0;
            AU_EXE: signals = 11'b0_1_0_0_011_0_0_0_0;
            J_EXE:  signals = 11'b0_1_0_0_100_0_1_0_0;
            JL_EXE: signals = 11'b0_1_0_0_100_0_1_1_0;
            S_EXE:  signals = 11'b0_0_1_0_000_0_0_0_0;
            S_MEM:  signals = 11'b0_0_1_1_000_0_0_0_1;
            L_EXE:  signals = 11'b0_0_1_0_001_0_0_0_0;
            L_MEM:  signals = 11'b0_0_1_0_001_0_0_0_1;
            L_WB:   signals = 11'b0_1_1_0_001_0_0_0_0;
        endcase
    end
endmodule
```

## APB_Master.sv
```verilog
`timescale 1ns / 1ps

module APB_Master (
    // global signals
    input  logic        PCLK,   // APB Clock
    input  logic        PRESET, // APB reset 
    // APB Interface Signals
    output logic [31:0] PADDR,
    output logic        PWRITE,
    output logic        PENABLE,
    output logic [31:0] PWDATA,
    output logic        PSEL0,      // RAM
    output logic        PSEL1,      // GPO
    output logic        PSEL2,      // GPI
    output logic        PSEL3,      // GPIO

    input  logic [31:0] PRDATA0,    // RAM
    input  logic [31:0] PRDATA1,    // GPO
    input  logic [31:0] PRDATA2,    // GPI
    input  logic [31:0] PRDATA3,    // GPIO

    input  logic        PREADY0,    // RAM
    input  logic        PREADY1,    // GPO
    input  logic        PREADY2,    // GPI
    input  logic        PREADY3,    // GPIO
    // Interanl Interface Signals
    input  logic        transfer,
    output logic        ready,
    input  logic        write,
    input  logic [31:0] addr,
    input  logic [31:0] wdata,
    output logic [31:0] rdata
);

    logic [3:0] pselx;
    logic [1:0] mux_sel;
    logic       decoder_en;
    logic [31:0] temp_addr_reg, temp_addr_next, temp_wdata_reg, temp_wdata_next;
    logic temp_write_reg, temp_write_next;

    assign PSEL0 = pselx[0];
    assign PSEL1 = pselx[1];
    assign PSEL2 = pselx[2];
    assign PSEL3 = pselx[3];

    typedef enum {
        IDLE,
        SETUP,
        ACCESS
    } apb_state_e;

    apb_state_e state, state_next;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            state <= IDLE;
            temp_addr_reg <= 0;
            temp_wdata_reg <= 0;
            temp_write_reg <= 0;
        end else begin
            state <= state_next;
            temp_addr_reg <= temp_addr_next;
            temp_wdata_reg <= temp_wdata_next;
            temp_write_reg <= temp_write_next;
        end
    end

    always_comb begin
        state_next      = state;
        decoder_en      = 1'b0;
        PENABLE         = 1'b0;
        temp_addr_next  = temp_addr_reg;
        temp_wdata_next = temp_wdata_reg;
        temp_write_next = temp_write_reg;
        PADDR           = temp_addr_reg;
        PWRITE          = temp_write_reg;
        PWDATA          = temp_wdata_reg;
        case (state)
            IDLE: begin
                decoder_en = 1'b0;  //sel signal 0
                if (transfer) begin
                    state_next = SETUP;
                    temp_addr_next = addr;      //latching
                    temp_wdata_next = wdata;    //latching
                    temp_write_next = write;    //latching
                end
            end
            SETUP: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b0;
                PADDR      = temp_addr_reg;
                PWRITE     = temp_write_reg;
                state_next = ACCESS;
                if (temp_write_reg) begin
                    PWDATA = temp_wdata_reg;
                end
            end
            ACCESS: begin
                decoder_en = 1'b1;
                PENABLE    = 1'b1;
                if (ready) begin
                    state_next = IDLE;
                end
            end
        endcase
    end

    APB_Decoder U_APB_Decoder (
        .en     (decoder_en),
        .sel    (temp_addr_reg),
        .y      (pselx),
        .mux_sel(mux_sel)
    );

    APB_Mux U_APB_Mux (
        .sel   (mux_sel),
        .rdata0(PRDATA0),
        .rdata1(PRDATA1),
        .rdata2(PRDATA2),
        .rdata3(PRDATA3),
        .ready0(PREADY0),
        .ready1(PREADY1),
        .ready2(PREADY2),
        .ready3(PREADY3),
        .rdata (rdata),
        .ready (ready)
    );

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Decoder (
    input  logic        en,
    input  logic [31:0] sel,
    output logic [ 3:0] y,
    output logic [ 1:0] mux_sel
);

    always_comb begin
        y = 4'b0000;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: y = 4'b0001;
                32'h1000_1xxx: y = 4'b0010;
                32'h1000_2xxx: y = 4'b0100;
                32'h1000_3xxx: y = 4'b1000;
            endcase
        end
    end

    always_comb begin
        mux_sel = 2'dx;
        if (en) begin
            casex (sel)
                32'h1000_0xxx: mux_sel = 2'd0;  // RAM
                32'h1000_1xxx: mux_sel = 2'd1;  // GPO
                32'h1000_2xxx: mux_sel = 2'd2;  // GPI
                32'h1000_3xxx: mux_sel = 2'd3;  // GPIO
            endcase
        end
    end

endmodule

///////////////////////////////////////////////////////////////////////////////////////////////////

module APB_Mux (
    input  logic [ 1:0] sel,
    input  logic [31:0] rdata0,
    input  logic [31:0] rdata1,
    input  logic [31:0] rdata2,
    input  logic [31:0] rdata3,
    input  logic        ready0,
    input  logic        ready1,
    input  logic        ready2,
    input  logic        ready3,
    output logic [31:0] rdata,
    output logic        ready
);

    always_comb begin
        rdata = 32'b0;
        case (sel)
            2'd0: rdata = rdata0;   // RAM
            2'd1: rdata = rdata1;   // GPO
            2'd2: rdata = rdata2;   // GPI
            2'd3: rdata = rdata3;   // GPIO
        endcase
    end

    always_comb begin
        ready = 1'b0;
        case (sel)
            2'd0: ready = ready0;   // RAM
            2'd1: ready = ready1;   // GPO
            2'd2: ready = ready2;   // GPI
            2'd3: ready = ready3;   // GPIO
        endcase
    end
endmodule
```

## APB_Slave.sv
```verilog
`timescale 1ns / 1ps

module APB_Slave (
    input logic PCLK,   // APB Clock
    input logic PRESET, // APB reset 

    // APB Interface Signals
    input  logic [ 3:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY
);
    logic [31:0] slv_reg0, slv_reg1, slv_reg2, slv_reg3;

    always_ff @(posedge PCLK, posedge PRESET) begin
        if (PRESET) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
            slv_reg2 <= 0;
            slv_reg3 <= 0;
        end else begin
            PREADY <= 1'b0;
            if (PSEL && PENABLE) begin
                PREADY <= 1'b1;
                if (PWRITE) begin
                    case (PADDR[3:2])
                        2'd0: slv_reg0 <= PWDATA; 
                        2'd1: slv_reg1 <= PWDATA;
                        2'd2: slv_reg2 <= PWDATA;
                        2'd3: slv_reg3 <= PWDATA; 
                    endcase
                end else begin  //write 아니고 read일 때
                    case (PADDR[3:2])
                        2'd0: PRDATA <= slv_reg0; 
                        2'd1: PRDATA <= slv_reg1;
                        2'd2: PRDATA <= slv_reg2;
                        2'd3: PRDATA <= slv_reg3; 
                    endcase
                end
            end
        end
    end
endmodule
```

## RAM.sv
```verilog
`timescale 1ns / 1ps

module RAM (
    //Global Signals
    input  logic        PCLK,
    input  logic        PRESET,
    // APB Interface Signals
    input  logic [ 5:0] PADDR,
    input  logic        PWRITE,
    input  logic        PENABLE,
    input  logic [31:0] PWDATA,
    input  logic        PSEL,
    output logic [31:0] PRDATA,
    output logic        PREADY
);
    logic [31:0] mem[0:2**4-1];  // 0x00 ~ 0x0f => 0x10 * 4 => 0x40

    always_ff @(posedge PCLK) begin
        PREADY <= 1'b0;
        if (PSEL && PENABLE) begin
            PREADY <= 1'b1;
            if (PWRITE) begin
                mem[PADDR[3:2]] <= PWDATA;
            end else begin
                PRDATA <= mem[PADDR[3:2]];
            end
        end
    end
endmodule
```
## Simulation
```verilog
`timescale 1ns / 1ps

module tb_apb ();
    //Global Signals
    logic        PCLK;
    logic        PRESET;

    logic [31:0] PADDR;
    logic        PWRITE;
    logic        PENABLE;
    logic [31:0] PWDATA;
    logic        PSEL0;
    logic        PSEL1;
    logic        PSEL2;
    logic        PSEL3;
    logic [31:0] PRDATA0;
    logic [31:0] PRDATA1;
    logic [31:0] PRDATA2;
    logic [31:0] PRDATA3;
    logic        PREADY0;
    logic        PREADY1;
    logic        PREADY2;
    logic        PREADY3;
    logic        PREADY;
    logic        PSEL;
    logic [31:0] PRDATA;
    logic        transfer;
    logic        ready;
    logic        write;
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;

    APB_Master U_APB_Master (.*);

    RAM U_RAM (
        .*,
        .PADDR (PADDR[11:0]),
        .PSEL  (PSEL0),
        .PRDATA(PRDATA0),
        .PREADY(PREADY0)
    );

    APB_Slave U_APB_Slave1 (
        .*,
        .PSEL  (PSEL1),
        .PRDATA(PRDATA1),
        .PREADY(PREADY1)
    );

    APB_Slave U_APB_Slave2 (
        .*,
        .PSEL  (PSEL2),
        .PRDATA(PRDATA2),
        .PREADY(PREADY2)
    );

    always #5 PCLK = ~PCLK;

    initial begin
        PCLK   = 0;
        PRESET = 1;
        #10;
        PRESET = 0;
    end

    task automatic apb_write(input logic [31:0] apb_addr, input logic [31:0] apb_wdata);
        @(posedge PCLK);
        #1;
        write = 1;
        addr = apb_addr;
        wdata = apb_wdata;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait(ready);
    endtask  

    task automatic apb_read(input logic [31:0] apb_addr);
        @(posedge PCLK);
        #1;
        write = 0;
        addr = apb_addr;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait(ready);
    endtask

    initial begin
        #10;
        apb_write(32'h1000_0000, 32'd1);
        apb_write(32'h1000_0004, 32'd2);
        apb_write(32'h1000_0008, 32'd3);

        apb_read(32'h1000_0000);
        apb_read(32'h1000_0004);
        apb_read(32'h1000_0008);

        @(posedge PCLK);
        #1;
        write = 1;
        addr = 32'h1000_1000;
        wdata = 32'd11;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait (ready);

        @(posedge PCLK);
        #1;
        write = 1;
        addr = 32'h1000_2000;
        wdata = 32'd12;
        transfer = 1;
        @(posedge PCLK);
        #1;
        transfer = 0;
        wait (ready);

        // @(posedge PCLK);
        // #1;
        // write = 1;
        // addr = 32'h1000_3000;
        // wdata = 32'd20;
        // transfer = 1;
        // @(posedge PCLK);
        // #1;
        // transfer = 0;
        // wait (ready);

        // @(posedge PCLK);
        // #1;
        // write = 0;
        // addr = 32'h1000_3000;
        // transfer = 1;
        // @(posedge PCLK);
        // #1;
        // transfer = 0;
        // wait (ready);

        #50;
        $finish;
    end
endmodule
```

다음과 같이 Task를 활용한다.

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 101656.png>)

READ Write 동작을 확인 가능 

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 101608.png>)


### Top을 MCU로 시뮬
![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 115616.png>)
또한 C-> Assembly 할 때, 0x10001000으로 초기화(SP 주소)

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 115548.png>)

---

# GPO

![alt text](<../../../assets/img/CPU/APB2/스크린샷 2025-08-28 123028.png>)
