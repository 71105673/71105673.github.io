---
title: "RV32I-APB Day-3"
date: "2025-09-02"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

## 🟦 Verilog vs SystemVerilog 비교

| 구분 | Verilog | SystemVerilog |
|------|----------|----------------|
| OOP(객체지향) | X | O |
| 데이터 타입 | **H/W** 중심 | **S/W** 중심 |
| InterFace | X | **SW <=> HW 연결** (DUT와 검증용 SW를 연결해주는 것들)|
| Randomization  | randome(제한적)  | 각 변수에 **random** 생성과 **constraint** 가능 -> coner case 생성 |

---
Verification(S/W -> SystemVerilog) <-> DUT(Verilog, SystemVerilog, VHDL) 
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 095856.png>)

### System Verilog Data Type

| 구분 | 상태 | 타입 | 비트 수 | 비고 |
|------|------|------|---------|------|
| **Vector 타입** | 4-state | `logic`, `reg`, `wire` | 사용자 정의 (N비트) | 값: 0, 1, x, z |
|                  | 2-state | `bit` | 사용자 정의 (N비트) | 값: 0, 1 |
| **Integer 타입** | 4-state | `integer` | 32비트 | 값: 0, 1, x, z |
|                  | 2-state | `byte` | 8비트  | 값: 0, 1 |
|                  | 2-state | `shortint` | 16비트 | 값: 0, 1 |
|                  | 2-state | `int` | 32비트 | 값: 0, 1 |
|                  | 2-state | `longint` | 64비트 | 값: 0, 1 |

## 배열
**고정 길이 배열**(Fixed-size array) C언어 배열과 비슷하다

**Run Time**에 배열 크기 변경할 수 없다

- bit arr[8]
- byte arr2[4]
- int arr3[16]

**동적 배열**(Dynamic Array)
**Run Time**에 배열 크기 변경할 수 있다.
- bit arr[]; arr = new[8]; ...
- byte arr2[]; arr2 = new[4];
- int arr3[]; arr3 = new[16];
  
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 103336.png>)

## Queue
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 104756.png>)

## Test Bench -> UVM 구조의 System Verilog 검증
**<Simple 구조>**
 ![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 105753.png>)
Stimulaus -> 입력 데이터

Generator: 생성
Driver: 전달
Moniter: 감시 -> 정보가 잘 전달 되는지
ScoreBoard: Pass or Fale 판단 

## 실습
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 114942.png>)

mail box => FIFO, Queue 기능을 SystemVerilog 공유 메모리에서 제공

### tb_adder.sv
```verilog
`timescale 1ns / 1ps

interface adder_intf;   // InterFace
    logic [7:0] a;
    logic [7:0] b;
    logic [7:0] result;
endinterface //adder_intf

class transaction;      // Data의 묶음
    rand bit [7:0] a;
    rand bit [7:0] b;
endclass //transaction

class generator;        // Class의 값을 생성
    transaction tr;
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox);
        this.gen2drv_mbox = gen2drv_mbox;   // this.() -> 이 클래스의 멤버에 매개변수로 들어온 new()라는애를 연결해준다.
    endfunction 

    task run(int run_count);
        repeat (run_count) begin
            tr = new();     // make instance. 실체화 시킨다. memory에 class 자료형을 만든다.
            tr.randomize(); // a, b라는 rand bit 변수에 값을 넣겠다. 라는 소리
            gen2drv_mbox.put(tr);   // random하게 생성된 핸들러 값을 메일박스에 넣겠다.
            #10;
        end
    endtask 

endclass //generator

class driver;
    transaction tr;                 // 자료형을 받을 수 있어야 한다.
    virtual adder_intf adder_if;    // 인터페이스 변수형으로 adder_if
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox, virtual adder_intf adder_if);
        this.gen2drv_mbox = gen2drv_mbox;   // 매개변수를 연결시켜주겠다.     
        this.adder_if = adder_if;           // 매개변수를 연결시켜주겠다. 
    endfunction 

    task run();
        forever begin
            gen2drv_mbox.get(tr);   // 만들어둔 tr에 이 값을 넣겠다.
            adder_if.a = tr.a;      // 그리고 interface에 넘기겠다.
            adder_if.b = tr.b;
        end
    endtask 
endclass //driver

class environment;
    generator gen;
    driver drv;
    mailbox #(transaction) gen2drv_mbox;

    function new(virtual adder_intf adder_if);
        gen2drv_mbox = new();       // mailbox라는 것을 실제 메모리에 생성 -> 인스턴스화
        gen = new(gen2drv_mbox);
        drv = new(gen2drv_mbox, adder_if);
    endfunction //new()

    task run();
        fork
            gen.run(20);    // 매개변수 20번 돌린다
            drv.run();
        join_any
        #100 $finish;
    endtask 

endclass //environment

module tb_adder ();
    environment env;
    adder_intf adder_if();
    adder dut(
        .a(adder_if.a),
        .b(adder_if.b),
        .result(adder_if.result)
    );

    initial begin
        env = new(adder_if);    // 이 떄, 인스턴스가 실제 만들어지며, inf정보가 env에 들어간다.
        env.run();
    end

endmodule
```

### Virtual
![alt text](<스크린샷 2025-09-02 124918.png>)

Virtual -> H/W를 S/W에 연결해주기 위한 과정 

why?? -> Class는 S/W이기 때문에 Test에서도 보이지 않는다.

즉 가상을 이용해서 해결