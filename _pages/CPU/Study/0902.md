---
title: "RV32I-APB Day-3"
date: "2025-09-02"
thumbnail: "../../../assets/img/CPU/APB/image.png"
---

## 🟦 Verilog vs SystemVerilog 비교

| 구분 | Verilog | SystemVerilog |
|------|----------|----------------|
| OOP(객체지향) | X | O |
| 데이터 타입 | **H/W** 중심 | **S/W** 중심 |
| InterFace | X | **SW <=> HW 연결** (DUT와 검증용 SW를 연결해주는 것들)|
| Randomization  | randome(제한적)  | 각 변수에 **random** 생성과 **constraint** 가능 -> coner case 생성 |

---
Verification(S/W -> SystemVerilog) <-> DUT(Verilog, SystemVerilog, VHDL) 
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 095856.png>)

### System Verilog Data Type

| 구분 | 상태 | 타입 | 비트 수 | 비고 |
|------|------|------|---------|------|
| **Vector 타입** | 4-state | `logic`, `reg`, `wire` | 사용자 정의 (N비트) | 값: 0, 1, x, z |
|                  | 2-state | `bit` | 사용자 정의 (N비트) | 값: 0, 1 |
| **Integer 타입** | 4-state | `integer` | 32비트 | 값: 0, 1, x, z |
|                  | 2-state | `byte` | 8비트  | 값: 0, 1 |
|                  | 2-state | `shortint` | 16비트 | 값: 0, 1 |
|                  | 2-state | `int` | 32비트 | 값: 0, 1 |
|                  | 2-state | `longint` | 64비트 | 값: 0, 1 |

## 배열
**고정 길이 배열**(Fixed-size array) C언어 배열과 비슷하다

**Run Time**에 배열 크기 변경할 수 없다

- bit arr[8]
- byte arr2[4]
- int arr3[16]

**동적 배열**(Dynamic Array)
**Run Time**에 배열 크기 변경할 수 있다.
- bit arr[]; arr = new[8]; ...
- byte arr2[]; arr2 = new[4];
- int arr3[]; arr3 = new[16];
  
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 103336.png>)

## Queue
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 104756.png>)

## Test Bench -> UVM 구조의 System Verilog 검증
**<Simple 구조>**
 ![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 105753.png>)
Stimulaus -> 입력 데이터

Generator: 생성
Driver: 전달
Moniter: 감시 -> 정보가 잘 전달 되는지
ScoreBoard: Pass or Fale 판단 

## 실습
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 114942.png>)

mail box => FIFO, Queue 기능을 SystemVerilog 공유 메모리에서 제공

### tb_adder.sv
```verilog
`timescale 1ns / 1ps

interface adder_intf;   // InterFace
    logic [7:0] a;
    logic [7:0] b;
    logic [7:0] result;
endinterface //adder_intf

class transaction;      // Data의 묶음
    rand bit [7:0] a;
    rand bit [7:0] b;
endclass //transaction

class generator;        // Class의 값을 생성
    transaction tr;
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox);
        this.gen2drv_mbox = gen2drv_mbox;   // this.() -> 이 클래스의 멤버에 매개변수로 들어온 new()라는애를 연결해준다.
    endfunction 

    task run(int run_count);
        repeat (run_count) begin
            tr = new();     // make instance. 실체화 시킨다. memory에 class 자료형을 만든다.
            tr.randomize(); // a, b라는 rand bit 변수에 값을 넣겠다. 라는 소리
            gen2drv_mbox.put(tr);   // random하게 생성된 핸들러 값을 메일박스에 넣겠다.
            #10;
        end
    endtask 

endclass //generator

class driver;
    transaction tr;                 // 자료형을 받을 수 있어야 한다.
    virtual adder_intf adder_if;    // 인터페이스 변수형으로 adder_if
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox, virtual adder_intf adder_if);
        this.gen2drv_mbox = gen2drv_mbox;   // 매개변수를 연결시켜주겠다.     
        this.adder_if = adder_if;           // 매개변수를 연결시켜주겠다. 
    endfunction 

    task run();
        forever begin
            gen2drv_mbox.get(tr);   // 만들어둔 tr에 이 값을 넣겠다.
            adder_if.a = tr.a;      // 그리고 interface에 넘기겠다.
            adder_if.b = tr.b;
        end
    endtask 
endclass //driver

class environment;
    generator gen;
    driver drv;
    mailbox #(transaction) gen2drv_mbox;

    function new(virtual adder_intf adder_if);
        gen2drv_mbox = new();       // mailbox라는 것을 실제 메모리에 생성 -> 인스턴스화
        gen = new(gen2drv_mbox);
        drv = new(gen2drv_mbox, adder_if);
    endfunction //new()

    task run();
        fork
            gen.run(20);    // 매개변수 20번 돌린다
            drv.run();
        join_any
        #100 $finish;
    endtask 

endclass //environment

module tb_adder ();
    environment env;
    adder_intf adder_if();
    adder dut(
        .a(adder_if.a),
        .b(adder_if.b),
        .result(adder_if.result)
    );

    initial begin
        env = new(adder_if);    // 이 떄, 인스턴스가 실제 만들어지며, inf정보가 env에 들어간다.
        env.run();
    end

endmodule
```

### Virtual
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 125409.png>)

Virtual -> H/W를 S/W에 연결해주기 위한 과정 

why?? -> Class는 S/W이기 때문에 Test에서도 보이지 않는다.

즉 가상을 이용해서 해결

### fork - join: Multi Processor

gen의 run과 driver의 run이 독립적으로 processor 생성한다.

🔵 fork-join 종류

| 구문 | 의미 |
|------|------|
| fork ... join | 모든 프로세스가 끝날 때까지 기다림 |
| fork ... join_any | 하나라도 끝나면 나머지를 무시하고 바로 빠져나감 |
| fork ... join_none | 아무것도 기다리지 않고 바로 다음 코드 실행 |

### 결과
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 125633.png>)

### 설명
mailbox를 확인하고 있다가 들어오면 interface로 보내는 역할을 driver의 run에서 실행중
```verilog
task run(int run_count);
    repeat (run_count) begin
        tr = new();    
        tr.randomize(); 
        gen2drv_mbox.put(tr);   
        #10;
    end
endtask 
```
해당 구문에서 new()를 매번 하여도 가비지 값은 알아서 반환되는 자바의 기능이 들어있다.


## Scoreboard
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 144206.png>)


## 실습 2
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 105753.png>)

### adder.sv
```verilog
`timescale 1ns / 1ps

module adder (
    input  logic       clk,
    input  logic [7:0] a,
    input  logic [7:0] b,
    output logic [8:0] result
);
    always_ff @( posedge clk ) begin
        result <= a + b;
    end
endmodule
```

### tb_adder.sv
```verilog
`timescale 1ns / 1ps

interface adder_intf;   // InterFace
    logic       clk;
    logic [7:0] a;
    logic [7:0] b;
    logic [8:0] result;
endinterface //adder_intf

class transaction;      // Data의 묶음
    rand bit [7:0] a;
    rand bit [7:0] b;
    bit [8:0] result;
endclass //transaction

class generator;        // Class의 값을 생성
    transaction tr;
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox);
        this.gen2drv_mbox = gen2drv_mbox;   // this.() -> 이 클래스의 멤버에 매개변수로 들어온 new()라는애를 연결해준다.
    endfunction 

    task run(int run_count);
        repeat (run_count) begin
            tr = new();     // make instance. 실체화 시킨다. memory에 class 자료형을 만든다.
            tr.randomize(); // a, b라는 rand bit 변수에 값을 넣겠다. 라는 소리
            gen2drv_mbox.put(tr);   // random하게 생성된 핸들러 값을 메일박스에 넣겠다.
            #10;
        end
    endtask 
endclass //generator

class driver;
    transaction tr;                 // 자료형을 받을 수 있어야 한다.
    virtual adder_intf adder_if;    // 인터페이스 변수형으로 adder_if
    mailbox #(transaction) gen2drv_mbox;

    function new(mailbox #(transaction) gen2drv_mbox, virtual adder_intf adder_if);
        this.gen2drv_mbox = gen2drv_mbox;   // 매개변수를 연결시켜주겠다.     
        this.adder_if = adder_if;           // 매개변수를 연결시켜주겠다. 
    endfunction 

    task run();
        forever begin
            gen2drv_mbox.get(tr);   // 만들어둔 tr에 이 값을 넣겠다.
            adder_if.a = tr.a;      // 그리고 interface에 넘기겠다.
            adder_if.b = tr.b;
            @(posedge adder_if.clk);
        end
    endtask 
endclass //driver

class monitor;
    transaction tr;                 // 자료형을 받을 수 있어야 한다.
    virtual adder_intf adder_if;    // 인터페이스 변수형으로 adder_if
    mailbox #(transaction) mon2scb_mbox;

    function new(mailbox #(transaction) mon2scb_mbox, virtual adder_intf adder_if);
        this.mon2scb_mbox = mon2scb_mbox;   // 매개변수를 연결시켜주겠다.     
        this.adder_if = adder_if;           // 매개변수를 연결시켜주겠다. 
    endfunction 

    task run();
        forever begin
            tr = new();
            @(posedge adder_if.clk);
            #1;
            tr.a = adder_if.a;
            tr.b = adder_if.b;
            tr.result = adder_if.result;
            mon2scb_mbox.put(tr);
        end
    endtask 
endclass //monitor

class scoreboard;
    transaction tr;
    mailbox #(transaction) mon2scb_mbox;
    bit [7:0] a, b;

    function new(mailbox #(transaction) mon2scb_mbox);
        this.mon2scb_mbox = mon2scb_mbox;
    endfunction //new()

    task run();
        // tr = new();
        forever begin
            mon2scb_mbox.get(tr);
            a = tr.a;
            b = tr.b;
            if (tr.result == (a + b)) begin
                $display("Pass!: %d + %d = %d", a, b, tr.result);
            end else begin
                $display("FAIL!: %d + %d = %d", a, b, tr.result);
            end
        end
    endtask 
endclass //scoreboard

class environment;
    generator gen;
    driver drv;
    monitor mon;
    scoreboard scb;
    mailbox #(transaction) gen2drv_mbox;
    mailbox #(transaction) mon2scb_mbox;

    function new(virtual adder_intf adder_if);
        gen2drv_mbox = new();       // mailbox라는 것을 실제 메모리에 생성 -> 인스턴스화
        mon2scb_mbox = new(); 
        gen = new(gen2drv_mbox);
        drv = new(gen2drv_mbox, adder_if);
        mon = new(mon2scb_mbox, adder_if);
        scb = new(mon2scb_mbox);
    endfunction //new()

    task run();
        fork
            gen.run(10);    // 매개변수 n번 돌리기
            drv.run();
            mon.run();
            scb.run();
        join_any
        #100 $finish;
    endtask 

endclass //environment

module tb_adder ();
    environment env;
    adder_intf adder_if();

    adder dut(
        .clk(adder_if.clk),
        .a(adder_if.a),
        .b(adder_if.b),
        .result(adder_if.result)
    );

    always #5 adder_if.clk = ~adder_if.clk;

    initial begin
        adder_if.clk = 1;
    end

    initial begin
        env = new(adder_if);    // 이 떄, 인스턴스가 실제 만들어지며, inf정보가 env에 들어간다.
        env.run();
    end

endmodule
```

### 결과
**clk**을 기준으로 동기화 

![text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 153656.png>) 
![text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 153701.png>)


## Home Work - UVM 구조로 RAM 검증하기 
**자동화 검증(입력 값)** ->  **Generator에서 Random값**
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-02 155049.png>)

**S/W로 만든 DUT와 실제 DUT에서 보낸 값이 일치하는지를 확인하는 것**

![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-03 095600.png>)

**RAM Timing**
![alt text](<../../../assets/img/CPU/APB3/스크린샷 2025-09-03 105850.png>)


# 추가사항 -> CPU RAM Byte, Half
```verilog
    always_ff @(posedge clk) begin
        if (we) begin
            case (size)
                2'b00: begin
                    mem[addr+0] <= wdata[7:0];
                end
                2'b01: begin
                    mem[addr+0] <= wdata[7:0];
                    mem[addr+1] <= wdata[15:8];
                end
                2'b10: begin
                    mem[addr+0] <= wdata[7:0];
                    mem[addr+1] <= wdata[15:8];
                    mem[addr+2] <= wdata[23:16];
                    mem[addr+3] <= wdata[31:24];
                end
            endcase
        end
    end
```
